<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Viite | API test results</title>
    <script src="./src/d3.v7.min.js"></script>
    <!-- <script src="https://d3js.org/d3.v7.min.js"></script> -->
    <link rel="stylesheet" href="./css/styles.css">
    <link rel="stylesheet" href="./css/vayla.css">
</head>
<body>
    <!-- <a href="./index.html"><img src="./src/vayla_sivussa_fi_sv_rgb.png" width="494" height="200"></a> -->
    <a href="./index.html"><img src="./src/vayla_sivussa_fi_sv_rgb.png" width="20%" height="20%"></a>
    <h1>Viite</h1>
    <h2 id="result_type"></h2>
    <!-- <h4 id="environment"></h4> -->
    <!-- <h4 id="time"></h4> -->

    <div id="daily_result_information" class="content"></div>

    <div id="daily_results" class="content"></div>

    <div id="daily_summary" class="content">
        <!-- <h2 id="daily_summary_header">Daily Summary</h2> -->
    </div>
    
    <!--
    <div id="graph" class="content">
        <h2 id="result_type">Graph</h2>
        <div id="my_dataviz"></div>
        <div id="tooltip" class="tooltip"></div>
    </div>
    -->

    <div id="environments_graph" class="content">
        <h2 id="result_type">Passed API Tests Over Time in All Environments</h2>
        <div id="environments_dataviz"></div>
        <!-- <div id="environments_tooltip" class="tooltip"></div> -->
    </div>

    <div id="environment_requests_graph" class="content">
        <h2 id="result_type">Response Times for API Test Requests Over Time in the Production Environment</h2>
        <div id="environment_requests_dataviz"></div>
        <!-- <div id="environment_requests_tooltip" class="tooltip"></div> -->
    </div>

    <div id="tooltip" class="tooltip"></div>

    

    <script>

        // TS 29.7.2024: Checked
        // Should this be inside main-function?
        const urlParams = new URLSearchParams(window.location.search);
        const environmentQueryParam = urlParams.get('environment');
        console.log(environmentQueryParam);
        const timeValueQueryParam = urlParams.get('time');
        console.log(timeValueQueryParam);
        const dataEntryIndexQueryParam = urlParams.get('dataEntryIndex');
        const resultIndexQueryParam = urlParams.get('resultIndex');

        // TS 29.7.2024: Checked
        document.addEventListener('DOMContentLoaded', () => {
            main();
        });

        /********
         ********
         * main *
         ********
         ********/

        async function main() {

            const baseURL = getBaseURL();

            // TS 29.7.2024: Checked
            // Remove commented code lines if app works
            // document.getElementById('graph').classList.remove('active');
            document.getElementById('environments_graph').classList.remove('active');
            document.getElementById('environment_requests_graph').classList.remove('active');
            document.getElementById('daily_result_information').classList.remove('active');
            document.getElementById('daily_summary').classList.remove('active');
            document.getElementById('daily_results').classList.remove('active');

            if (timeValueQueryParam && environmentQueryParam && dataEntryIndexQueryParam && resultIndexQueryParam) {
                setElementVisibleByElementId("daily_result_information");
                setElementVisibleByElementId("daily_summary");
                // document.getElementById('daily_result_information').classList.remove('content');
                // document.getElementById('daily_result_information').classList.add('active');
                // document.getElementById('daily_summary').classList.remove('content');
                // document.getElementById('daily_summary').classList.add('active');
                // fetchDataAndShowDailySummary();

                // const url = `${baseURL}${timeValueQueryParam}/results-${environmentQueryParam}.json`;
                const url = `${baseURL}${getDateTimeByEnvironment(timeValueQueryParam)}/results-${environmentQueryParam}.json`;
                fetchDataAndHandleErrors(url, "my_dataviz", showDailySummary);

                /*
                try {
                    const data = await fetchData(url);
                    showDailySummary(data);
                }
                catch (error) {
                    console.error('Error fetching data:', error);
                }
                */

            }
            else if (timeValueQueryParam && environmentQueryParam && resultIndexQueryParam) {
                setElementVisibleByElementId("daily_result_information");
                setElementVisibleByElementId("daily_summary");
                // document.getElementById('daily_result_information').classList.remove('content');
                // document.getElementById('daily_result_information').classList.add('active');
                // document.getElementById('daily_summary').classList.remove('content');
                // document.getElementById('daily_summary').classList.add('active');
                // fetchDataAndShowDailySummary();

                // const url = `${baseURL}${getDateTimeByEnvironment(timeValueQueryParam)}/results-${environmentQueryParam}.json`;
                // fetchDataAndHandleErrors(url, "my_dataviz", showDailySummary);

                /*
                try {
                    const data = await fetchData(url);
                    showDailySummary(data);
                }
                catch (error) {
                    console.error('Error fetching data:', error);
                }
                */

            }
            else if (timeValueQueryParam && environmentQueryParam) {
                setElementVisibleByElementId("daily_result_information");
                setElementVisibleByElementId("daily_summary");
                // document.getElementById('daily_result_information').classList.remove('content');
                // document.getElementById('daily_result_information').classList.add('active');
                // document.getElementById('daily_summary').classList.remove('content');
                // document.getElementById('daily_summary').classList.add('active');
                // fetchDataAndShowDailySummary();

                const url = `${baseURL}${getDateTimeByEnvironment(timeValueQueryParam)}/results-${environmentQueryParam}.json`;
                fetchDataAndHandleErrors(url, "my_dataviz", showDailySummary);

                /*
                try {
                    const data = await fetchData(url);
                    showDailySummary(data);
                }
                catch (error) {
                    console.error('Error fetching data:', error);
                }
                */

            }
            else {
                // setElementVisibleByElementId("graph");
                setElementVisibleByElementId("environments_graph");
                setElementVisibleByElementId("environment_requests_graph");
                
                // document.getElementById('graph').classList.remove('content');
                // document.getElementById('graph').classList.add('active');
                // fetchDataAndShowGraph();

                // const url = `${baseURL}summary.json`;
                // fetchDataAndHandleErrors(url, "my_dataviz", showGraph);

                const environments_url = `${baseURL}data/summary.json`;
                fetchDataAndHandleErrors(environments_url, "environments_dataviz", showEnvironmentsGraph);

                // const environment_requests_url = `${baseURL}${getDateTimeByEnvironment(timeValueQueryParam)}/response_time-prod.json`;
                // const environment_requests_url = `${baseURL}${timeValueQueryParam}/response_time-prod.json`;
                const environment_requests_url = `${baseURL}data/responseTimes.json`;
                // const environment_requests_url = `${baseURL}data/responseTimes.json`;
                fetchDataAndHandleErrors(environment_requests_url, "environment_requests_dataviz", showEnvironmentRequestsGraph);
                console.log(environment_requests_url);

                /*
                try {
                    const data = await fetchData(url);
                    showGraph(data);
                }
                catch (error) {
                    console.error('Error fetching data:', error);
                }
                */

            }
        }

        // TS 29.7.2024: Checked
        function setElementVisibleByElementId(elementId) {
            const element = document.getElementById(elementId);
            if (element) {
                element.classList.remove("content");
                element.classList.add("active");
            }
        }

        // TS 29.7.2024: Checked
        function isLocal() {
            return window.location.protocol === 'file:';
        }

        // TS 29.7.2024: Checked
        // Determine base URL based on environment
        function getBaseURL() {
            if ( isLocal() ) {
                return 'http://localhost:3000/'; // Local development URL
            } else {
                return './'; // Production environment URL
            }
        }

        // TS 29.7.2024: Checked
        function gotoLoginPage() {
            if ( isLocal() ) {
                window.location.href = "https://viiteapitest.testivaylapilvi.fi/oauth2/";
                return;
            }
            window.location.href = "./oauth2/"; // USE THIS ON THE SERVER
            return; 
        }

        // TS 29.7.2024: Checked
        async function fetchDataAndHandleErrors(url, divContainerId, callback) {
            try {
                const data = await fetchData(url);
                if (data) {
                    callback(data, divContainerId);
                } else {
                    console.error('No data returned');
                }
            } catch (error) {
                console.error('Error fetching data:', error);
            }
        }

        // TS 29.7.2024: Checked
        function fetchData(url) {

            return fetch(url) // TOIMII
            .then(response => {
                if (!response.ok) {
                    // console.log(response);
                    console.log(response.status);
                    switch(response.status) {
                        case 403: 
                            gotoLoginPage();
                            return; 
                            /*
                            if ( isLocal() ) {
                                window.location.href = "https://viiteapitest.testivaylapilvi.fi/oauth2/";
                                return
                            }
                            window.location.href = "./oauth2/"; // USE THIS ON THE SERVER
                            return; 
                            */
                        case 404:
                            // gotoLoginPage();
                            // return;
                            // 
                            // window.location.href = "https://viiteapitest.testivaylapilvi.fi/oauth2/"; // DON*T USE THIS ON THE SERVER
                            // return; // DON*T USE THIS ON THE SERVER
                            throw new Error('404 Not Found: The requested resource could not be found.');    
                        case 500: 
                            throw new Error('500 Internal Environment Error: An error occurred on the environment.');
                        default: 
                            throw new Error(`HTTP error! status: ${response.status}`);
                    }
                }
                return response.json();
            })
            .catch(error => {
                if (error instanceof Error) {
                    console.error('Caught error: ', error.message);
                } 
                else {
                    console.error('Unknown error occurred: ', error);
                }
            });

        }

        function getDateTimeByEnvironment(date) {
            if ( isLocal() ) {
                const dateTimeInLocalFormat = convertDateTimeToLocalFormatZ(date); 
                return dateTimeInLocalFormat;
            }
            return date;
        }

        function convertDateTimeToLocalFormatZ(dateTime) {
            const dateTimeInLocalFormat = new Date(dateTime);
            if (isNaN(dateTimeInLocalFormat.getTime())) {
                throw new Error("Invalid date format");
            }

            const year = dateTimeInLocalFormat.getUTCFullYear();
            const month = String(dateTimeInLocalFormat.getUTCMonth() + 1).padStart(2, '0');
            const day = String(dateTimeInLocalFormat.getUTCDate()).padStart(2, '0');
            const hours = String(dateTimeInLocalFormat.getUTCHours()).padStart(2, '0');
            const minutes = String(dateTimeInLocalFormat.getUTCMinutes()).padStart(2, '0');
            const seconds = String(dateTimeInLocalFormat.getUTCSeconds()).padStart(2, '0');
            const offset_hours = dateTime.slice(-5, -3); 
            const offset_minutes = dateTime.slice(-2, -1) + dateTime.slice(-1);

            return `${year}-${month}-${day}T${hours}-${minutes}-${seconds}Z`;
        }

        function convertDateTimeToLocalFormat(dateTime) {
            const dateTimeInLocalFormat = new Date(dateTime);
            if (isNaN(dateTimeInLocalFormat.getTime())) {
                throw new Error("Invalid date format");
            }

            const year = dateTimeInLocalFormat.getUTCFullYear();
            const month = String(dateTimeInLocalFormat.getUTCMonth() + 1).padStart(2, '0');
            const day = String(dateTimeInLocalFormat.getUTCDate()).padStart(2, '0');
            const hours = String(dateTimeInLocalFormat.getUTCHours()).padStart(2, '0');
            const minutes = String(dateTimeInLocalFormat.getUTCMinutes()).padStart(2, '0');
            const seconds = String(dateTimeInLocalFormat.getUTCSeconds()).padStart(2, '0');
            const offset_hours = dateTime.slice(-5, -3); 
            const offset_minutes = dateTime.slice(-2, -1) + dateTime.slice(-1);

            return `${year}-${month}-${day}T${hours}-${minutes}-${seconds}%2B${offset_hours}-${offset_minutes}`;
        }

        /*************
         *************
         * showGraph *
         *************
         *************/

        function showGraph(data, dataReady, dataSeries, divContainerId, xLabel, yLabel) {


            // console.log("data:", data);
            // console.log("dataReady:", dataReady);

            // document.getElementById('result_type').innerText = "Graph";

            // set the dimensions and margins of the graph
            const margin = {top: 50, right: 250, bottom: 50, left: 70};
            let width = window.innerWidth - margin.left - margin.right - 40;
            let height = window.innerHeight - margin.top - margin.bottom - 80; 
        

            
            let isMouseOverSvg = false;
            let isMouseOverCircle = false;

            // Define zoom behavior
            const zoom = d3.zoom()
                .scaleExtent([1, 500]) // min and max zoom
                // .translateExtent([[0, 0], [width, height]])
                .wheelDelta(function(event) { return -event.deltaY * 0.01; })
                .filter( event => {
                    return event.ctrlKey; // Zoom only when Ctrl key is pressed
                    // return event.ctrlKey && event.button === 0;
                    // return (event.ctrlKey || event.type === 'wheel') || (event.ctrlKey && event.button === 1);
                })
                .on("zoom", event => {
                    if (isMouseOverSvg && event.sourceEvent) {
                        updateChart(event);
                    }
                });
            
            // append the svg object to the body of the page
            const svg = d3.select(`#${divContainerId}`)
                .append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                .append("g")
                    .attr("transform",`translate(${margin.left},${margin.top})`)
                .on("mouseenter", event => { 
                    isMouseOverSvg = true;
                    event.preventDefault();
                    printDebugMessages();
                })
                .on("mouseleave", () => { 
                    isMouseOverSvg = false;
                    printDebugMessages();
                })
                // .call(zoom);

            const rect = svg.append("rect")
                .attr("width", width)
                .attr("height", height)
                .style("fill", "none")
                .style("pointer-events", "all")
                .attr('transform', `translate(0,0)`)
                .call(zoom);





            // ALIOHJELMA ALKAA

            // Parse the date / time
            // const parseDate = d3.timeParse("%Y-%m-%d");
            // const parseDate = d3.timeParse("%Y-%m-%dT%H:%M:%S%Z");
            const parseDate = d3.utcParse("%Y-%m-%dT%H:%M:%S%Z");
            const formatDate = d3.utcFormat("%Y-%m-%dT%H:%M:%S%Z");

            /*
            data.forEach( (d) => {
                d.date = parseDate(d.date);
            });
            */

            /*
            const parsedData1 = [];
            for (let key in data) {
                // const parsedDate = parseDate(key.replace(/\//g, ""));
                const parsedDate = key.replace(/\//g, "");
                parsedData1.push({
                    date: parsedDate,
                    dev: data[key].dev,
                    qa: data[key].qa,
                    prod: data[key].prod
                });
            }
            */

            /*
            const parsedData2 = [];
            for (let key in data) {
                if (data.hasOwnProperty(key)) {
                    parsedData2.push({
                        date: key.replace(/\//g, ""), // Säilytetään alkuperäinen päivämäärämerkkijono
                        dev: data[key].dev,
                        qa: data[key].qa,
                        prod: data[key].prod
                    });
                }
            }
            */

            // console.log("parsedData2:", parsedData2)
            

            // console.log(parsedData);
            
            // sorts parsedData by date and time in ascending order
            /*
            parsedData2.sort((a, b) => {
                const dateA = new Date(a.date);
                const dateB = new Date(b.date);
                return dateA - dateB;
            });
            */

            // console.log("parsedData:", parsedData2);
            
            // let parsedData2 = parsedData;
            
            // console.log(parsedData);

            // List of environments
            // const allEnvironments = ["prod", "qa", "dev"];

            // environmentName is stored two times in the data. Can this be fixed?
            // Reformat the data
            /*
            const dataReady = allEnvironments.map(environmentName => {
                return {
                    name: environmentName,
                    values: parsedData2.map(d => {
                        return {date: d.date, value: +d[environmentName], environment: environmentName};
                    })
                };
            });
            */
            
            // Check that the data is ready
            // console.log(dataReady);

            // const allEnvironments = ["prod", "qa", "dev"];
            // A color scale: one color for each group
            const myColor = d3.scaleOrdinal()
                // .domain(allEnvironments)
                .domain(dataSeries)
                // .range(d3.schemeSet2);
                // .range(["#0064AF", "#0099FF", "#49C2F1"]);
                .range(["#0064AF", "#0099FF", "#49C2F1", "#00B0CC", "#207A43", "#8DCB6D", "#FFC300", "#910AA3", "#C73F00", "#FF5100", "#E50083"]); // Customer's colors are being used

            // Generate unique tick values for the initial state
            // const initialTicks = data.map(d => new Date(d.date))
                // .filter((d, i, self) => self.findIndex(t => t.getTime() === d.getTime()) === i);

            // Add X axis --> it is a date format
            const x = d3.scaleTime()
            // const x = d3.scaleUtc()
                .domain(d3.extent(data, d => new Date(d.date)))
                .range([ 0, width ]);

            const xAxis = d3.axisBottom(x);

            const gx = svg.append("g")
                .attr("transform", `translate(0,${height})`)
                // .call(xAxis);
                .call(createXAxis(x));
            
            // gx.call(createXAxis(x));
            


            /*
            const xAxis = svg.append("g")
                .attr("transform", `translate(0, ${height})`)
                .call(d3.axisBottom(x)
                    .tickValues(initialTicks)
                    .tickFormat(d3.timeFormat("%Y-%m-%d %H:%M:%S"))
                    // .tickSize(0) // Ei viivoja
                    .tickPadding(10) // Puskuri akseleiden ja tekstien välillä
                );
                // .call(d3.axisBottom(x));
                // .call(d3.axisBottom(x).ticks(2));
            */

            let xAxisLabel = svg.append("text")
                .attr("transform", `translate(${width / 2},${height + margin.bottom - 10})`)
                .style("text-anchor", "middle")
                .text(xLabel);
                // .text(Object.keys(dataReady[0].values[0])[0].toUpperCase());



            // Add Y axis
            /*
            const y = d3.scaleLinear()
                .domain([0, d3.max(data, d => Math.max(d.prod, d.qa, d.dev) )])
                .nice()
                .range([ height, 0 ]);
            */

            const y = d3.scaleLinear()
                .domain([0, d3.max(dataReady.flatMap(d => d.values), d => d.value)])
                .nice()
                .range([height, 0]);

            const yAxis = d3.axisLeft(y);

            const gy = svg.append("g")
                // .call(yAxis);
                .call(createYAxis(y));
            
            // gy.call(createYAxis(y));

            /*
            const yAxis = svg.append("g")
                .call(d3.axisLeft(y)
                    .tickFormat(d3.format("d"))
                );
                // .call(d3.axisLeft(y).ticks(20));
            */

            let yAxisLabel =  svg.append("text")
                .attr("transform", `rotate(-90)`)
                .attr("y", 0 - margin.left + 20)
                .attr("x", 0 - (height / 2))
                .style("text-anchor", "middle")
                .text(yLabel);
                // .text(Object.keys(dataReady[0].values[0])[1].toUpperCase());


            // Add the lines
            const line = d3.line()
                .x(d => x(+(new Date(d.date))))
                .y(d => y(+d.value));

            /*
            svg.selectAll("myLines")
                .data(dataReady)
                .join("path")
                    .attr("d", d => line(d.values))
                    .attr("stroke", d => myColor(d.name))
                    .style("stroke-width", 4)
                    .style("fill", "none")
            */

            // Moved elsewhere
            /*
            // Define zoom behavior
            const zoom = d3.zoom()
                .scaleExtent([0.5, 1000]) // min and max zoom
                .extent([[0, 0], [width, height]])
                .filter( event => {
                    return event.ctrlKey; // Zoom only when Ctrl key is pressed
                    // return event.ctrlKey && event.button === 0;
                    // return (event.ctrlKey || event.type === 'wheel') || (event.ctrlKey && event.button === 1);
                })
                .on("zoom", event => {
                    if (isMouseOverSvg && event.sourceEvent) {
                        updateChart(event);
                    }
                });
            */

            // Moved elsewhere
            /*
            svg.on("mouseenter", event => { 
                isMouseOverSvg = true;
                event.preventDefault();
                printDebugMessages();
            });
            */

            // Moved elsewhere
            /*
            svg.on("mouseleave", () => { 
                isMouseOverSvg = false;
                printDebugMessages();
            });
            */

            // svg.call(zoom);

            // Add a clipPath: everything out of this area won't be drawn.
            const clip = svg.append("defs")
                .append("svg:clipPath")
                .attr("id", "clip")
                .append("svg:rect")
                .attr("width", width )
                .attr("height", height )
                .attr("x", 0)
                .attr("y", 0);

            /******************
            * Mouse functions *
            *******************/

            function mouseover(event, d) {
                if (!event.ctrlKey) {
                    isMouseOverCircle = true;
                    showTooltip(event, d);
                } 
            }

            function mouseout() {
                isMouseOverCircle = false;
                hideTooltip();
            }

            function mouseclick(event, d) {
                // formattedDate = formatDate(d.date);
                // const timezone = formattedDate.slice(-6); // +00:00
                // const isoString = `${formattedDate.slice(0,19)}%2B${timezone.slice(2, 4)}:${timezone.slice(4)}`;
                // window.location.href = `?environment=${d.environment}&time=${encodeURIComponent(d.date)}`;
                // window.location.href = `?environment=${d.environment}&time=${encodeURIComponent(d.date)}`;
                window.location.href = `?environment=${d.name}&time=${encodeURIComponent(d.date)}`;
            }

            // Create the scatter variable: where both the circles and the brush take place
            const scatter = svg.append('g')
                .attr("clip-path", "url(#clip)")

            // Add lines
            scatter
                .selectAll("myLines")
                .data(dataReady)
                .join("path")
                    .attr("data-env", d => d.name)
                    .attr("class", "path")
                    .attr("stroke", d => myColor(d.name))
                    .attr("d", d => line(d.values))
                    .style("stroke-width", 4)
                    .style("fill", "none");

            // Add circles
            scatter
                // First we need to enter in a group
                .selectAll("myDots")
                .data(dataReady)
                .join('g')
                    .attr('data-env', d => d.name)
                    .style("fill", d => myColor(d.name))
                // Second we need to enter in the 'values' part of this group
                .selectAll("myPoints")
                .data(d => d.values)
                .join("circle")
                    .attr("data-env", (d, i, nodes) => {
                        // `nodes` are the circle DOM elements, and we can use the parent `g` element to get the data-env
                        const parentG = d3.select(nodes[i].parentNode); // Select the parent <g> element
                        return parentG.attr('data-env'); // Get the data-env attribute value from the parent <g>
                    })
                    // .attr("data-env", d => d.environment)
                    .attr("cx", d => x(new Date(d.date)))
                    .attr("cy", d => y(d.value))
                    .attr("r", 5)
                    .attr("stroke", "white")
                    .on("mouseover", mouseover)
                    .on("mouseout", mouseout)
                    .on("click", mouseclick);

            /*************
             * Functions *
             *************/
            
            /*********************
             * Tooltip functions *
             *********************/

            function showTooltip(event, d) {
                const tooltip = document.getElementById("tooltip");
                tooltip.style.display = "block";
                tooltip.style.left = event.pageX + 15 + "px";
                tooltip.style.top = event.pageY + 15 +"px";
                // tooltip.textContent = "Tooltip: You are over the circle.";
                // tooltip.textContent = `environment: ${d.environment} passed tests: ${d.value} date: ${d.date}`;
                tooltip.innerHTML = `
                    name: ${d.name}<br>
                    value: ${d.value}<br>
                    date: ${d.date}
                `;
                console.log(d);
            }

            function showTooltip3(event, d) {
                const tooltip = document.getElementById("tooltip");
                tooltip.style.display = "block";
                tooltip.style.left = event.pageX + 15 + "px";
                tooltip.style.top = event.pageY + 15 +"px";
                // tooltip.textContent = "Tooltip: You are over the circle.";
                // tooltip.textContent = `environment: ${d.environment} passed tests: ${d.value} date: ${d.date}`;
                tooltip.innerHTML = `
                    environment: ${d.environment}<br>
                    passed tests: ${d.value}<br>
                    date: ${d.date}
                `;
            }

            function showTooltip4(event, d) {
                const tooltip = d3.select("#tooltip");

                tooltip.transition()
                    .duration(200)
                    .style("opacity", .9);

                tooltip
                    .style("display", "block")
                    .style("left", (event.pageX + 15) + "px")
                    .style("top", (event.pageY + 15) + "px")
                    .html(`
                        environment: ${d.environment}<br>
                        passed tests: ${d.value}<br>
                        date: ${d.date}
                    `);

                tooltip.transition()
                    .duration(200)
                    .style("opacity", .9);
            }

            function hideTooltip() {
                const tooltip = document.getElementById("tooltip");
                tooltip.style.display = "none";
            }



            /*******************
             * Other functions *
             *******************/

            function createXAxis(scale) {       

                const tickIntervals = [1, 2, 3, 4, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50]; // Possible day intervals
                let minDistance = 50; // Minimum pixel distance between ticks

                let tickInterval = tickIntervals[0];
                for (let i = 1; i < tickIntervals.length; i++) {
                    const interval = tickIntervals[i];
                    const ticks = scale.ticks(d3.timeDay.every(interval));
                    minDistance = ticks.length + 60;
                    const avgTickDistance = width / ticks.length;
                    if (avgTickDistance >= minDistance) {
                        tickInterval = interval;
                        break;
                    }
                }

                // xAxis.call(d3.axisBottom(x).ticks(d3.timeDay.every(tickInterval)));

                return d3.axisBottom(scale)
                    . ticks(d3.timeDay.every(tickInterval))
                    // .tickValues(tickValues)
                    .tickFormat(d3.timeFormat("%Y-%m-%d"));



                /*
                const minTickSpacing = 80;
                const domain = scale.domain();
                const step = (domain[1] - domain[0]) / Math.max(1, Math.floor(width / minTickSpacing));
                const tickValues = [];

                let current = domain[0];
                while (current <= domain[1]) {
                    tickValues.push(current);
                    current = new Date(current.getTime() + step);
                }

                // Poista viimeinen tick
                tickValues.pop();

                return d3.axisBottom(scale)
                    .tickValues(tickValues)
                    .tickFormat(d3.timeFormat("%Y-%m-%d"));
                */
            }

            function createYAxis(scale) {
                const minTickSpacing = 50;
                const tickCount = Math.max(1, Math.floor(height / minTickSpacing));
                return d3.axisLeft(scale)
                    .ticks(tickCount)
                    .tickFormat(d3.format("d"));
            }

            // Debug messages
            function printDebugMessages() {
                console.log(`isMouseOverSvg: ${isMouseOverSvg}`);
                console.log("*****")
            }

            function isPathHiddenByDataEnv(dataEnv) {
                const paths = svg.selectAll(`path[data-env="${dataEnv}"]`);
                let isHidden = paths.classed("hidden");
                return isHidden;
            }
            
            function toggleLegendDimming(event, d, self) {
                const isActive = d3.select(self).classed("dimmed");
                d3.select(self).classed("dimmed", !isActive);
                svg.selectAll(`.line`).filter(lineD => lineD.name === d.name).style("display", isActive ? null : "none");
            }

            function setLegendVisibilityByDataEnv(dataEnv, visibility) {
                // const legend = d3.select(`#${id}`);
                const legends = svg.selectAll(`legend[data-env="${dataEnv}"]`);
                legends.classed("dimmed", visibility);
            }

            function setLegendVisibilityByD(d, visibility) {
                return setLegendVisibilityByDataEnv(d.name, visibility);
            }

            function setCircleVisibilityByDataEnv(dataEnv, visibility) {
                // const circle = d3.select(`#${id}`);
                const circles = svg.selectAll(`circle[data-env="${dataEnv}"]`);
                circles.classed("hidden", visibility);
            }

            function setCircleVisibilityByD(d, visibility) {
                return setCircleVisibilityByDataEnv(d.name, visibility);
            }

            function togglePathVisibilityByDataEnv(dataEnv) {
                // const path = d3.select(`#${id}`);
                const paths = svg.selectAll(`path[data-env="${dataEnv}"]`);
                // console.log(path);
                let isHidden = paths.classed("hidden");
                paths.classed("hidden", !isHidden)
                isHidden = paths.classed("hidden");
                return isHidden;
            }

            function togglePathVisibilityByD(d) {
                // console.log(d);
                // console.log(`path_${d.name}`);
                return togglePathVisibilityByDataEnv(d.name);
            }

            function toggleLegendAndPathAndCircleVisibilityByD(d, self) {
                const visibility = togglePathVisibilityByD(d); 
                setCircleVisibilityByD(d, visibility);
                d3.select(self).classed("dimmed", visibility)
                // setLegendVisibilityByD(d, visibility);
            }

            // Toggle visibility function
            function togglePathAndCircleVisibility(name) {
                // Select paths and circles by name
                const path = scatter.selectAll("path")
                    .filter(d => d.name === name);
                
                const circles = scatter.selectAll("circle")
                    .filter(function(d) {
                        return d3.select(this.parentNode).datum().name === name;
                    });

                // Toggle hidden class based on current state
                const isHidden = path.classed("hidden");
                path.classed("hidden", !isHidden);
                circles.classed("hidden", !isHidden);
            }

            // Add a legends
            const legend = svg.selectAll("myLegends")
                .data(dataReady)
                .enter()
                .append("g")
                    .attr("data-env", d => d.name)
                    .attr("class", "legend")
                    .attr("transform", (d, i) => `translate(${width + 20},${i * 20})`)
                    .on("click", function(event, d) {
                        toggleLegendAndPathAndCircleVisibilityByD(d, this); // OPTION 2
                        // toggleLegendDimming(event, d, this); // OPTION 1
                        // togglePathAndCircleVisibility(d.name); // OPTION 1
                    });


            legend.append("rect")
                .attr("x", 0)
                .attr("width", 18)
                .attr("height", 18)
                .style("fill", d => myColor(d.name))
                // .on("click", (event, d) => {
                    // togglePathAndCircleVisibility(d.name);
                // });

            legend.append("text")
                .attr("x", 24)
                .attr("y", 9)
                .attr("dy", ".35em")
                .style("text-anchor", "start")
                .text(d => d.name)
                // .on("click", (event, d) => {
                    // togglePathAndCircleVisibility(d.name);
                // });





            /**************
            ***************
            * updateChart *
            ***************
            ***************/

            // A function that updates the chart when the user zoom and thus new boundaries are available
            function updateChart(event) {

                // recover the new scale
                let newX = event.transform.rescaleX(x);
                let newY = event.transform.rescaleY(y);

                // Generate unique tick values based on the new scale's domain
                // const newDomain = newX.domain();
                // const uniqueTicks = data.map(d => new Date(d.date))
                    // .filter(d => d >= newDomain[0] && d <= newDomain[1])
                    // .filter((d, i, self) => self.findIndex(t => t.getTime() === d.getTime()) === i)

                // update axes with these new boundaries
                /*
                xAxis.call(d3.axisBottom(newX)
                    .tickValues(uniqueTicks)
                    .tickFormat(d3.timeFormat("%Y-%m-%d %H:%M:%S"))
                );
                */

                gx
                    .attr("transform", `translate(0,${height})`)
                    .call(createXAxis(newX));

                gy.call(createYAxis(newY));

                scatter
                    .selectAll("path")
                    .attr("d", d => d3.line()
                        .x(d => newX(+(new Date(d.date))))
                        .y(d => newY(+d.value))(d.values)
                    );

                // update circles
                scatter
                    .selectAll("circle")
                    .attr("cx", d => newX(new Date(d.date)))
                    .attr("cy", d => newY(d.value));
            }

            /***********************
            ************************
            * updateLegendPosition *
            ************************
            ************************/

            // Function to update legend position
            function updateLegendPosition() {
                const legendSpacing = 20;
                const legendWidth = 100;
                const totalGroups = dataReady.length;
                const svgWidth = width + margin.left + margin.right;
                const legendX = svgWidth - legendWidth - 10; // Position legend on the right

                const legend = svg.selectAll(".legend")
                    .data(dataReady)
                    .enter()
                    .append("g")
                    .attr("class", "legend")
                    .classed("dimmed", d => isPathHiddenByDataEnv(d.name))
                    .attr("transform", (d, i) => `translate(${width + 20},${i * 20})`)
                    .on("click", function(event, d) {
                        toggleLegendAndPathAndCircleVisibilityByD(d, this); // OPTION 2
                        // toggleLegendDimming(event, d, this); // OPTION 1
                        // togglePathAndCircleVisibility(d.name); // OPTION 1
                    });
                    // .attr("transform", (d, i) => `translate(${legendX},${i * legendSpacing})`);

                legend.append("rect")
                    .attr("x", 0)
                    .attr("width", 18)
                    .attr("height", 18)
                    .style("fill", d => myColor(d.name))
                    // .on("click", (event, d) => {
                        // togglePathAndCircleVisibility(d.name);
                    // });

                legend.append("text")
                    .attr("x", 24)
                    .attr("y", 9)
                    .attr("dy", ".35em")
                    .style("text-anchor", "start")
                    .text(d => d.name)
                    // .on("click", (event, d) => {
                        // togglePathAndCircleVisibility(d.name);
                    // });

                xAxisLabel.remove();
                
                xAxisLabel = svg.append("text")
                    .attr("transform", `translate(${width / 2},${height + margin.bottom - 10})`)
                    .style("text-anchor", "middle")
                    .text(xLabel);
                    // .text(Object.keys(dataReady[0].values[0])[0].toUpperCase());

                yAxisLabel.remove();

                yAxisLabel = svg.append("text")
                    .attr("transform", `rotate(-90)`)
                    .attr("y", 0 - margin.left + 20)
                    .attr("x", 0 - (height / 2))
                    .style("text-anchor", "middle")
                    .text(yLabel);
                    // .text(Object.keys(dataReady[0].values[0])[1].toUpperCase());
            }

            /**************************
            ***************************
            * window.addEventListener *
            ***************************
            ***************************/

            // Event listener to handle Ctrl key state and tooltip display
            window.addEventListener('keydown', event => {
                if (event.key === 'Control' && isMouseOverCircle) {
                    hideTooltip();
                }
            });

            // DOES NOT WORK, showTooltip CAUSES EXECPTION
            window.addEventListener('keyup', (event) => {
                if (event.key === 'Control' && isMouseOverCircle) {
                    // Causes exception
                    showTooltip(event);
                }
            });

            // DOES NOT WORK, IF CTRL IS BEING PRESSED
            // WORKS ONLY WHEN WHEEL IS BEING USED
            // Prevent default scroll behavior when Ctrl key is pressed
            window.addEventListener('wheel', event => {
                // if (event.ctrlKey && isMouseOverSvg && (isMouseOverCircle || svg.node().contains(event.target))) {
                if (event.ctrlKey && isMouseOverSvg) {
                    event.preventDefault();
                }
            }, { passive: false });

            window.addEventListener("resize", () => {
                width = window.innerWidth - margin.left - margin.right - 40;
                height = window.innerHeight - margin.top - margin.bottom - 80;

                x.range([0, width]);
                y.range([height, 0]);

                gx
                    .attr("transform", `translate(0,${height})`)
                    .call(createXAxis(x));

                gy.call(createYAxis(y));

                svg
                    .attr('width', width + margin.left + margin.right)
                    .attr('height', height + margin.top + margin.bottom);

                svg.select('#clip rect')
                    .attr('width', width)
                    .attr('height', height);

                    // .translateExtent([[0, 0], [width, height]]);

                /*
                rect
                    .attr("width", width)
                    .attr("height", height);
                */
              


                /*
                xAxis.call(d3.axisBottom(x)
                    .tickValues(initialTicks)
                    .tickFormat(d3.timeFormat("%Y-%m-%d")))
                    .attr('transform', `translate(0,${height})`);

                yAxis.call(d3.axisLeft(y));
                */

                scatter.selectAll('path')
                    .attr('d', d => line(d.values));

                scatter.selectAll('circle')
                    .attr('cx', d => x(new Date(d.date)))
                    .attr('cy', d => y(d.value));

                // Remove and update legend
                svg.selectAll(".legend").remove(); // Remove existing legends
            
                // Update legend position
                updateLegendPosition();

            });

            // Tarvitaanko?
            // Initialize legend position
            // updateLegendPosition();
            
            // ALIOHJELMA PÄÄTTYY
        }

        function showEnvironmentsGraph(data, divContainerId) {

            console.log("data (showEnvironmentsGraph):", data);

            const parseDate = d3.utcParse("%Y-%m-%dT%H:%M:%S%Z");

            const parsedData = [];
            for (let key in data) {
                if (data.hasOwnProperty(key)) {
                    parsedData.push({
                        date: key.replace(/\//g, ""), // Säilytetään alkuperäinen päivämäärämerkkijono
                        dev: data[key].dev,
                        qa: data[key].qa,
                        prod: data[key].prod
                    });
                }
            }
            
            // sorts parsedData by date and time in ascending order
            parsedData.sort((a, b) => {
                const dateA = new Date(a.date);
                const dateB = new Date(b.date);
                return dateA - dateB;
            });

            const dataSeries = ["prod", "qa", "dev"];
            const dataReady = dataSeries.map(dataSerieName => {
                return {
                    name: dataSerieName,
                    values: parsedData.map(d => {
                        return {date: d.date, value: +d[dataSerieName], name: dataSerieName};
                    })
                };
            });

            console.log("parsedData (showEnvironmentsGraph):", parsedData);
            console.log("dataReady (showEnvironmentsGraph):", dataReady);

            showGraph(parsedData, dataReady, dataSeries, divContainerId, "Time", "Passed Tests [pcs]");
        }

        function showEnvironmentRequestsGraph(data, divContainerId) {

            console.log("data (showEnvironmentRequestsGraph):", data);

            // const parseDate = d3.utcParse("%Y-%m-%dT%H:%M:%S%Z");
            const parseDate = d3.utcParse("%Y-%m-%dT%H:%M:%SZ");


            // Suodattamalla vain "prod" ympäristö
            const prodData = data.filter(d => d.env === "prod");

            // Luo parsedData vain "prod" ympäristölle
            const parsedData = prodData.map(d => ({
                date: d.timestamp,
                value: d.responseTime,
                test: d.test,
                env: d.env
            }));

            // const parsedData = [];
            /*
            const parsedData = data.map(d => ({
                date: d.timestamp,
                test: d.response_time, 
            }));
            */

            // sorts parsedData by date and time in ascending order
            /*
            parsedData.sort((a, b) => {
                const dateA = new Date(a.date);
                const dateB = new Date(b.date);
                return dateA - dateB;
            });
            */

            const dataSeries = [
                "GET https://devapi.testivaylapilvi.fi/viite/api/viite/changes/road_numbers?since={{since_var}}&until={{until_var}}", 
                "GET https://devapi.testivaylapilvi.fi/viite/api/viite/integration/linear_location/changes?since={{since_var}}", 
                "GET https://devapi.testivaylapilvi.fi/viite/api/viite/integration/road_address?municipality={{municipality_var}}", 
                "GET https://devapi.testivaylapilvi.fi/viite/api/viite/integration/roadnames/changes?since={{since_var}}", 
                "GET https://devapi.testivaylapilvi.fi/viite/api/viite/integration/roadway/changes?since={{since_var}}", 
                "GET https://devapi.testivaylapilvi.fi/viite/api/viite/integration/roadway_changes/changes?since={{since_var}}", 
                "GET https://devapi.testivaylapilvi.fi/viite/api/viite/integration/summary", 
                "GET https://devapi.testivaylapilvi.fi/viite/api/viite/search/road_address/{{road_var}}/{{roadPart_var}}/{{startAddress_var}}/{{endAddress_var}}/?", 
                "GET https://devapi.testivaylapilvi.fi/viite/api/viite/search/road_address/{{road_var}}/{{roadPart_var}}/{{address_var}}/?", 
                "GET https://devapi.testivaylapilvi.fi/viite/api/viite/search/road_address/{{road_var}}/{{roadPart_var}}/?", 
                "GET https://devapi.testivaylapilvi.fi/viite/api/viite/search/road_address/{{road_var}}/", 
                "GET https://devapi.testivaylapilvi.fi/viite/api/viite/search/road_address/?linkId={{linkId_var}}", 
                "GET https://devapi.testivaylapilvi.fi/viite/api/viite/search/road_numbers?"
            ];

            // Luo dataReady vain "prod" ympäristölle
            const dataReady = Array.from(
                d3.group(parsedData, d => d.test),
                ([key, values]) => ({ name: key, values: values})
            );

            /*
            const dataReady = dataSeries.map(dataSerieName => {
                return {
                    name: dataSerieName,
                    values: data.map(d => {
                        return {date: d.timestamp, value: +d.response_time, dataSerie: dataSerieName};
                    })
                };
            });
            */
            
            console.log("parsedData (showEnvironmentRequestsGraph):", parsedData);
            console.log("dataReady (showEnvironmentRequestsGraph):", dataReady);
            
            showGraph(parsedData, dataReady, dataSeries, divContainerId, "Time", "Response Time [ms]");
        }

        function reminder() {

            const date1 = new Date("2023-10-01T10:00:00Z");
            const date2 = new Date("2024-01-01T00:00:00+00:00");

            console.log( date1.toString() );
            console.log( date1.toISOString() );

            console.log( date2.toString() );
            console.log( date2.toISOString() );

        }

        /********************
         ********************
         * showDailySummary *
         ********************
         * FUNCTIONS        *
         ********************
         ********************/


        function getSignByBoolean(isTrue) {
            if (isTrue) {
                return '<span style="color: green; font-size: 20px;">&#10003;</span>';
            }
            return '<span style="color: red; font-size: 20px;">&#10060;</span>';
        }
            
        function getSignByResult(result) {
            return getSignByBoolean(result === 'pass');
        }

        function addDailyResultInformation(timeValueQueryParam, environmentQueryParam) {
            if (timeValueQueryParam && environmentQueryParam) {
                const content = document.createElement('p');
                content.innerText = `Test execution time: ${timeValueQueryParam}`;
                document.getElementById('daily_result_information').appendChild(content);
            }
            if (environmentQueryParam) {
                const content = document.createElement('p');
                content.innerText = `Test environment: ${environmentQueryParam}`;
                document.getElementById('daily_result_information').appendChild(content);
            }

            // const horizontalLine = document.createElement('hr');
            // document.getElementById('daily_result_information').appendChild(horizontalLine);
        }

        /********************
         ********************
         * showDailySummary *
         ********************
         ********************/

        function showDailySummary(data) {

            // const formatDate = d3.utcFormat("%Y-%m-%dT%H-%M-%S%Z");

            // document.getElementById('result_type').innerText = "Daily summary";

            addDailyResultInformation(timeValueQueryParam, environmentQueryParam);

            let dataEntryIndex = 0;

            console.log(data)

            for (let dataIndex = 0; dataIndex < data.length; dataIndex++) {
                dataEntry = data[dataIndex];

                const contentDiv = document.createElement('div');
                contentDiv.innerHTML = `
                    <table>
                        <tr>
                            <td></td>
                            <td>Passed</td>
                            <td>Failed</td>
                            <td>Total</td>
                        </tr>
                        <tr>
                            <td>Requests</td>
                            <td>${dataEntry.summary.passedRequests}</td>
                            <td>${dataEntry.summary.failedRequests}</td>
                            <td>${dataEntry.summary.totalRequests}</td>
                        </tr>
                        <tr>
                            <td>Assertions</td>
                            <td>${dataEntry.summary.passedAssertions}</td>
                            <td>${dataEntry.summary.failedAssertions}</td>
                            <td>${dataEntry.summary.totalAssertions}</td>
                        </tr>
                        <tr>
                            <td>Tests</td>
                            <td>${dataEntry.summary.passedTests}</td>
                            <td>${dataEntry.summary.failedTests}</td>
                            <td>${dataEntry.summary.totalTests}</td>
                        </tr>
                    </table>
                `;
                document.getElementById('daily_summary').appendChild(contentDiv);

                const content = document.createElement('h3');                             
                content.innerText = `Requests`;
                document.getElementById('daily_summary').appendChild(content);

                for (let resultIndex = 0; resultIndex < dataEntry.results.length; resultIndex++) {
                    result = dataEntry.results[resultIndex]; 

                    let passedAssertionAmount = 0;
                    let totalAssertionAmount = result.assertionResults.length;

                    let passedTestAmount = 0;
                    let totalTestAmount = result.testResults.length;

                    const content = document.createElement('p');                             
                    content.innerHTML = `<span id="request_result_sign_${resultIndex}"></span> <span id="request_result_${resultIndex}"></span> <span id="request_result_numbers_${resultIndex}"></span> <a href="?environment=${environmentQueryParam}&time=${encodeURIComponent(timeValueQueryParam)}&dataEntryIndex=${dataEntryIndex}&resultIndex=${resultIndex}">${result.request.method} ${result.request.url}</a>`;
                    // content.innerHTML = `<span id="request_result_sign_${resultIndex}"></span> <span id="request_result_${resultIndex}"></span> <span id="request_result_numbers_${resultIndex}"></span> <a href="?environment=${environmentQueryParam}&time=${getDateTimeByEnvironment(timeValueQueryParam)}&dataEntryIndex=${dataEntryIndex}&resultIndex=${resultIndex}">${result.request.method} ${result.request.url}</a>`;
                    document.getElementById('daily_summary').appendChild(content); 

                    if (resultIndex == resultIndexQueryParam) {
                        document.getElementById('daily_summary').appendChild(document.createElement('p')).innerText = `Runtime: ${Math.round(result.runtime * 1000)} ms`;
                        document.getElementById('daily_summary').appendChild(document.createElement('p')).innerText = `Response time: ${result.response.responseTime} ms`;
                    }

                    /* Assertion results */

                    const assertionResultDiv = document.createElement('div');
                    const assertionResultTable = document.createElement('table');

                    const testResultDiv = document.createElement('div');
                    const testResultTable = document.createElement('table');

                    for (let assertionResultIndex = 0; assertionResultIndex < result.assertionResults.length; assertionResultIndex++) {
                        const assertionResult = result.assertionResults[assertionResultIndex];
                        console.log(assertionResult);
                        if (assertionResult.status === 'pass') { 
                            passedAssertionAmount++; 
                        }
                        if (resultIndexQueryParam && resultIndexQueryParam == resultIndex) {
                            assertionResultTable.innerHTML += `
                                <tr>
                                    <td>${getSignByResult(assertionResult.status)}</td>
                                    <td>${assertionResult.status.toUpperCase()}</td>
                                    <td>${assertionResult.lhsExpr} ${assertionResult.rhsExpr}</td>
                                </tr>
                            `;
                        }
                    }

                    /* Test results */

                    for (let testResultIndex = 0; testResultIndex < totalTestAmount; testResultIndex++) {
                        const testResult = result.testResults[testResultIndex];
                        if (testResult.status === 'pass') { 
                            passedTestAmount++; 
                        }
                        if (resultIndexQueryParam && resultIndexQueryParam == resultIndex) {
                            let errorMessage = "";
                            if (testResult.error) {
                                errorMessage = `, ERROR: "${testResult.error}"`;
                            }
                            testResultTable.innerHTML += `
                                <tr>
                                    <td>${getSignByResult(testResult.status)}</td>
                                    <td>${testResult.status.toUpperCase()}</td>
                                    <td>${testResult.description}${errorMessage}</td>
                                </tr>
                            `;
                        }
                    }

                    assertionResultDiv.appendChild(assertionResultTable);
                    document.getElementById('daily_summary').appendChild(assertionResultDiv);     
                    testResultDiv.appendChild(testResultTable);
                    document.getElementById('daily_summary').appendChild(testResultDiv);

                    /* All assertions and tests passed */
                    console.log(passedAssertionAmount);
                    console.log(passedTestAmount);
                    console.log(totalAssertionAmount);
                    console.log(totalTestAmount);
                    const assertionsAndRequestsPassed = (passedAssertionAmount+passedTestAmount)/(totalAssertionAmount+totalTestAmount) === 1;
                    console.log(assertionsAndRequestsPassed);
                    document.getElementById(`request_result_sign_${resultIndex}`).innerHTML = getSignByBoolean(assertionsAndRequestsPassed);
                    document.getElementById(`request_result_${resultIndex}`).innerHTML = `${assertionsAndRequestsPassed ? "PASS" : "FAIL"}`;
                    document.getElementById(`request_result_numbers_${resultIndex}`).innerHTML = `(${passedAssertionAmount+passedTestAmount}/${totalAssertionAmount+totalTestAmount})`;
                }

            }

        }

    </script>

</body>
</html>
