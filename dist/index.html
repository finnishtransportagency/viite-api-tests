<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Viite | API test results</title>
    <script src="./src/d3.v7.min.js"></script>
    <!-- <script src="https://d3js.org/d3.v7.min.js"></script> -->
    <link rel="stylesheet" href="./src/styles.css">
    <link rel="stylesheet" href="./src/vayla.css">
</head>
<body>
    <img src="./src/vayla_sivussa_fi_sv_rgb.png" width="494" height="200">
    <h1>Viite</h1>
    <h2>API test results</h2>
    <h3 id="result_type"></h3>
    <!-- <h4 id="server"></h4> -->
    <!-- <h4 id="time"></h4> -->

    <div id="daily_result_information" class="content"></div>

    <div id="daily_results" class="content"></div>

    <div id="daily_summary" class="content"></div>
    
    <div id="graph" class="content">
        <div id="my_dataviz"></div>
        <div id="tooltip" class="tooltip"></div>
    </div>

    

    <script>

        const urlParams = new URLSearchParams(window.location.search);
        const serverQueryParam = urlParams.get('server');
        const timeValueQueryParam = urlParams.get('time');
        const dataEntryIndexQueryParam = urlParams.get('dataEntryIndex');
        const resultIndexQueryParam = urlParams.get('resultIndex');

        document.getElementById('graph').classList.remove('active');
        document.getElementById('daily_result_information').classList.remove('active');
        document.getElementById('daily_summary').classList.remove('active');
        document.getElementById('daily_results').classList.remove('active');
        
        if (timeValueQueryParam && serverQueryParam && dataEntryIndexQueryParam && resultIndexQueryParam) {
            document.getElementById('daily_result_information').classList.add('active');
            document.getElementById('daily_summary').classList.add('active');
            showDailySummary();
        }
        else if (timeValueQueryParam && serverQueryParam && resultIndexQueryParam) {
            document.getElementById('daily_result_information').classList.add('active');
            document.getElementById('daily_summary').classList.add('active');
            showDailySummary();
        }
        else if (timeValueQueryParam && serverQueryParam) {
            document.getElementById('daily_result_information').classList.add('active');
            document.getElementById('daily_summary').classList.add('active');
            showDailySummary();
        }
        else {
            document.getElementById('graph').classList.add('active');
            readDataAndShowGraph();
        }

        function readDataAndShowGraph() {

            // d3.json("./data/summary.json").then( data => {
            // d3.json("http://localhost:3000/summary.json").then( data => { // TOIMII
            // d3.json("https://viiteapitest.testivaylapilvi.fi/data/summary.json").then( data => {

            // fetch("http://localhost:3000/summary.json") // TOIMII
            // fetch("http://localhost:3000/data/summary.json")
            // fetch('https://viiteapitest.testivaylapilvi.fi/data/summary.json')
            // fetch('https://viiteapitest.testivaylapilvi.fi/data/summary.json', { mode: "no-cors" } )
            fetch('./data/summary.json')
            .then(response => {
                if (!response.ok) {
                    // console.log(response);
                    console.log(response.status);
                    switch(response.status) {
                        case 403: 
                            window.location.href = "./oauth2/";
                            // window.location.href = "https://viiteapitest.testivaylapilvi.fi/oauth2/";
                            return; 
                        case 404:
                            throw new Error('404 Not Found: The requested resource could not be found.');
                        case 500: 
                            throw new Error('500 Internal Server Error: An error occurred on the server.');
                        default: 
                            throw new Error(`HTTP error! status: ${response.status}`);
                    }
                }
                return response.json();
            })
            .then(data => {
                return showGraph(data);
            })
            .catch(error => {
                if (error instanceof Error) {
                    console.error('Caught error: ', error.message);
                } 
                else {
                    console.error('Unknown error occurred: ', error);
                }
            });
        }


        function showGraph(data) {

            document.getElementById('result_type').innerText = "Graph";

            // set the dimensions and margins of the graph
            const margin = {top: 50, right: 250, bottom: 50, left: 50};
            let width = window.innerWidth - margin.left - margin.right - 40;
            let height = window.innerHeight - margin.top - margin.bottom - 80; 

            let isMouseOverSvg = false;
            let isMouseOverCircle = false;

            // Define zoom behavior
            const zoom = d3.zoom()
                .scaleExtent([0.5, 1000]) // min and max zoom
                .extent([[0, 0], [width, height]])
                .filter( event => {
                    return event.ctrlKey; // Zoom only when Ctrl key is pressed
                    // return event.ctrlKey && event.button === 0;
                    // return (event.ctrlKey || event.type === 'wheel') || (event.ctrlKey && event.button === 1);
                })
                .on("zoom", event => {
                    if (isMouseOverSvg && event.sourceEvent) {
                        updateChart(event);
                    }
                });
            
            // append the svg object to the body of the page
            const svg = d3.select("#my_dataviz")
                .append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                .append("g")
                    .attr("transform",`translate(${margin.left},${margin.top})`)
                .on("mouseenter", event => { 
                    isMouseOverSvg = true;
                    event.preventDefault();
                    printDebugMessages();
                })
                .on("mouseleave", () => { 
                    isMouseOverSvg = false;
                    printDebugMessages();
                })
                .call(zoom);

            const rect = svg.append("rect")
                .attr("width", width)
                .attr("height", height)
                .style("fill", "none")
                .style("pointer-events", "all")
                .attr('transform', `translate(0,0)`)
                // .call(zoom);

            // Tooltip functions
            function showTooltip(event, d) {
                const tooltip = document.getElementById("tooltip");
                tooltip.style.display = "block";
                tooltip.style.left = event.pageX + 15 + "px";
                tooltip.style.top = event.pageY + 15 +"px";
                // tooltip.textContent = "Tooltip: You are over the circle.";
                // tooltip.textContent = `environment: ${d.server} passed tests: ${d.value} date: ${d.date}`;
                tooltip.innerHTML = `
                    environment: ${d.server}<br>
                    passed tests: ${d.value}<br>
                    date: ${d.date}
                `;
            }

            function hideTooltip() {
                const tooltip = document.getElementById("tooltip");
                tooltip.style.display = "none";
            }

            // Debug messages
            function printDebugMessages() {
                console.log(`isMouseOverSvg: ${isMouseOverSvg}`);
                console.log("*****")
            }



            // ALIOHJELMA ALKAA

                // Parse the date / time
                // const parseDate = d3.timeParse("%Y-%m-%d");
                // const parseDate = d3.timeParse("%Y-%m-%dT%H:%M:%S%Z");
                const parseDate = d3.utcParse("%Y-%m-%dT%H:%M:%S%Z");
                const formatDate = d3.utcFormat("%Y-%m-%dT%H:%M:%S%Z");

                /*
                data.forEach( (d) => {
                    d.date = parseDate(d.date);
                });
                */

                /*
                const parsedData1 = [];
                for (let key in data) {
                    // const parsedDate = parseDate(key.replace(/\//g, ""));
                    const parsedDate = key.replace(/\//g, "");
                    parsedData1.push({
                        date: parsedDate,
                        dev: data[key].dev,
                        qa: data[key].qa,
                        prod: data[key].prod
                    });
                }
                */

                const parsedData = [];
                for (let key in data) {
                    if (data.hasOwnProperty(key)) {
                        parsedData.push({
                            date: key.replace(/\//g, ""), // Säilytetään alkuperäinen päivämäärämerkkijono
                            dev: data[key].dev,
                            qa: data[key].qa,
                            prod: data[key].prod
                        });
                    }
                }

                console.log(parsedData);
                // console.log(parsedData1);

                // List of servers
                const allServers = ["prod", "qa", "dev"];

                // serverName is stored two times in the data. Can this be fixed?
                // Reformat the data
                const dataByServers = allServers.map(serverName => {
                    return {
                        name: serverName,
                        values: parsedData.map(d => {
                            return {date: d.date, value: +d[serverName], server: serverName};
                        })
                    };
                });
                
                // Check that the data is ready
                console.log(dataByServers)

                // A color scale: one color for each group
                const myColor = d3.scaleOrdinal()
                    .domain(allServers)
                    // .range(d3.schemeSet2);
                    // .range(["#0064AF", "#0099FF", "#49C2F1"]);
                    .range(["#0064AF", "#0099FF", "#49C2F1", "#00B0CC", "#207A43", "#8DCB6D", "#FFC300", "#910AA3", "#C73F00", "#FF5100", "#E50083"]);

                // Generate unique tick values for the initial state
                const initialTicks = parsedData.map(d => new Date(d.date))
                    .filter((d, i, self) => self.findIndex(t => t.getTime() === d.getTime()) === i);

                // Add X axis --> it is a date format
                const x = d3.scaleTime()
                // const x = d3.scaleUtc()
                    .domain(d3.extent(parsedData, d => new Date(d.date)))
                    .range([ 0, width ]);
                const xAxis = svg.append("g")
                    .attr("transform", `translate(0, ${height})`)
                    .call(d3.axisBottom(x)
                        .tickValues(initialTicks)
                        .tickFormat(d3.timeFormat("%Y-%m-%d"))
                        // .tickSize(0) // Ei viivoja
                        .tickPadding(10) // Puskuri akseleiden ja tekstien välillä
                    );
                    // .call(d3.axisBottom(x));
                    // .call(d3.axisBottom(x).ticks(2));

                // Add Y axis
                const y = d3.scaleLinear()
                    .domain([0, d3.max(parsedData, d => Math.max(d.prod, d.qa, d.dev) )])
                    .range([ height, 0 ]);
                const yAxis = svg.append("g")
                    .call(d3.axisLeft(y)
                        .tickFormat(d3.format("d"))
                    );
                    // .call(d3.axisLeft(y).ticks(20));

                // Add the lines
                const line = d3.line()
                    .x(d => x(+(new Date(d.date))))
                    .y(d => y(+d.value));

                /*
                svg.selectAll("myLines")
                    .data(dataByServers)
                    .join("path")
                        .attr("d", d => line(d.values))
                        .attr("stroke", d => myColor(d.name))
                        .style("stroke-width", 4)
                        .style("fill", "none")
                */

                // Moved elsewhere
                /*
                // Define zoom behavior
                const zoom = d3.zoom()
                    .scaleExtent([0.5, 1000]) // min and max zoom
                    .extent([[0, 0], [width, height]])
                    .filter( event => {
                        return event.ctrlKey; // Zoom only when Ctrl key is pressed
                        // return event.ctrlKey && event.button === 0;
                        // return (event.ctrlKey || event.type === 'wheel') || (event.ctrlKey && event.button === 1);
                    })
                    .on("zoom", event => {
                        if (isMouseOverSvg && event.sourceEvent) {
                            updateChart(event);
                        }
                    });
                */

                // Moved elsewhere
                /*
                svg.on("mouseenter", event => { 
                    isMouseOverSvg = true;
                    event.preventDefault();
                    printDebugMessages();
                });
                */

                // Moved elsewhere
                /*
                svg.on("mouseleave", () => { 
                    isMouseOverSvg = false;
                    printDebugMessages();
                });
                */

                // svg.call(zoom);

                // Add a clipPath: everything out of this area won't be drawn.
                const clip = svg.append("defs")
                    .append("svg:clipPath")
                    .attr("id", "clip")
                    .append("svg:rect")
                    .attr("width", width )
                    .attr("height", height )
                    .attr("x", 0)
                    .attr("y", 0);

                // Create the scatter variable: where both the circles and the brush take place
                const scatter = svg.append('g')
                    .attr("clip-path", "url(#clip)")

                const mouseover = (event, d) => {
                    if (!event.ctrlKey) {
                        isMouseOverCircle = true;
                        showTooltip(event, d);
                    } 
                }

                const mouseout = () => {
                    isMouseOverCircle = false;
                    hideTooltip();
                }

                const mouseclick = (event, d) => {
                    // formattedDate = formatDate(d.date);
                    // const timezone = formattedDate.slice(-6); // +00:00
                    // const isoString = `${formattedDate.slice(0,19)}%2B${timezone.slice(2, 4)}:${timezone.slice(4)}`;
                    window.location.href = `?server=${d.server}&time=${encodeURIComponent(d.date)}`;
                }

                // Add lines
                scatter
                    .selectAll("myLines")
                    .data(dataByServers)
                    .join("path")
                        .attr("d", d => line(d.values))
                        .attr("stroke", d => myColor(d.name))
                        .style("stroke-width", 4)
                        .style("fill", "none");

                // Add circles
                scatter
                    // First we need to enter in a group
                    .selectAll("myDots")
                    .data(dataByServers)
                    .join('g')
                        .style("fill", d => myColor(d.name))
                    // Second we need to enter in the 'values' part of this group
                    .selectAll("myPoints")
                    .data(d => d.values)
                    .join("circle")
                        .attr("cx", d => x(new Date(d.date)))
                        .attr("cy", d => y(d.value))
                        .attr("r", 5)
                        .attr("stroke", "white")
                        .on("mouseover", mouseover)
                        .on("mouseout", mouseout)
                        .on("click", mouseclick);
                
                function toggleLegendDimming(event, d, self) {
                    const isActive = d3.select(self).classed("dimmed");
                    d3.select(self).classed("dimmed", !isActive);
                    svg.selectAll(`.line`).filter(lineD => lineD.name === d.name).style("display", isActive ? null : "none");
                }

                // Add a legends
                const legend = svg.selectAll("myLegends")
                    .data(dataByServers)
                    .enter()
                    .append("g")
                    .attr("class", "legend")
                    .attr("transform", (d, i) => `translate(${width + 20},${i * 20})`)
                    .on("click", function(event, d) {
                        toggleLegendDimming(event, d, this);
                        togglePathAndCircleVisibility(d.name);
                    });


                legend.append("rect")
                    .attr("x", 0)
                    .attr("width", 18)
                    .attr("height", 18)
                    .style("fill", d => myColor(d.name))
                    // .on("click", (event, d) => {
                        // togglePathAndCircleVisibility(d.name);
                    // });

                legend.append("text")
                    .attr("x", 24)
                    .attr("y", 9)
                    .attr("dy", ".35em")
                    .style("text-anchor", "start")
                    .text(d => d.name)
                    // .on("click", (event, d) => {
                        // togglePathAndCircleVisibility(d.name);
                    // });



                // Toggle visibility function
                function togglePathAndCircleVisibility(name) {
                    // Select paths and circles by name
                    const path = scatter.selectAll("path")
                        .filter(d => d.name === name);
                    
                    const circles = scatter.selectAll("circle")
                        .filter(function(d) {
                            return d3.select(this.parentNode).datum().name === name;
                        });

                    // Toggle hidden class based on current state
                    const isHidden = path.classed("hidden");
                    path.classed("hidden", !isHidden);
                    circles.classed("hidden", !isHidden);
                }

                // A function that updates the chart when the user zoom and thus new boundaries are available
                function updateChart(event) {

                    // recover the new scale
                    let newX = event.transform.rescaleX(x);
                    let newY = event.transform.rescaleY(y);

                    // Generate unique tick values based on the new scale's domain
                    const newDomain = newX.domain();
                    const uniqueTicks = parsedData.map(d => new Date(d.date))
                        .filter(d => d >= newDomain[0] && d <= newDomain[1])
                        .filter((d, i, self) => self.findIndex(t => t.getTime() === d.getTime()) === i)

                    // update axes with these new boundaries
                    xAxis.call(d3.axisBottom(newX)
                        .tickValues(uniqueTicks)
                        .tickFormat(d3.timeFormat("%Y-%m-%d")));
                    yAxis.call(d3.axisLeft(newY));

                    scatter
                        .selectAll("path")
                        .attr("d", d => d3.line()
                            .x(d => newX(+(new Date(d.date))))
                            .y(d => newY(+d.value))(d.values)
                        );

                    // update circles
                    scatter
                        .selectAll("circle")
                        .attr("cx", d => newX(new Date(d.date)))
                        .attr("cy", d => newY(d.value));
                }

                // Function to update legend position
                function updateLegendPosition() {
                    const legendSpacing = 20;
                    const legendWidth = 100;
                    const totalGroups = dataByServers.length;
                    const svgWidth = width + margin.left + margin.right;
                    const legendX = svgWidth - legendWidth - 10; // Position legend on the right

                    const legend = svg.selectAll(".legend")
                        .data(dataByServers)
                        .enter()
                        .append("g")
                        .attr("class", "legend")
                        .attr("transform", (d, i) => `translate(${width + 20},${i * 20})`)
                        .on("click", function(event, d) {
                            toggleLegendDimming(event, d, this);
                            togglePathAndCircleVisibility(d.name);
                        });
                        // .attr("transform", (d, i) => `translate(${legendX},${i * legendSpacing})`);

                    legend.append("rect")
                        .attr("x", 0)
                        .attr("width", 18)
                        .attr("height", 18)
                        .style("fill", d => myColor(d.name))
                        // .on("click", (event, d) => {
                            // togglePathAndCircleVisibility(d.name);
                        // });

                    legend.append("text")
                        .attr("x", 24)
                        .attr("y", 9)
                        .attr("dy", ".35em")
                        .style("text-anchor", "start")
                        .text(d => d.name)
                        // .on("click", (event, d) => {
                            // togglePathAndCircleVisibility(d.name);
                        // });
                }

                // Event listener to handle Ctrl key state and tooltip display
                window.addEventListener('keydown', event => {
                    if (event.key === 'Control' && isMouseOverCircle) {
                        hideTooltip();
                    }
                });

                window.addEventListener('keyup', (event, d) => {
                    if (event.key === 'Control' && isMouseOverCircle) {
                        // Causes exception
                        showTooltip(event, d);
                    }
                });

                // Prevent default scroll behavior when Ctrl key is pressed
                window.addEventListener('wheel', event => {
                    // if (event.ctrlKey && isMouseOverSvg && (isMouseOverCircle || svg.node().contains(event.target))) {
                    if (event.ctrlKey && isMouseOverSvg) {
                        console.log("preventDefault");
                        event.preventDefault();
                    }
                }, { passive: false });

                window.addEventListener("resize", () => {
                    width = window.innerWidth - margin.left - margin.right - 40;
                    height = window.innerHeight - margin.top - margin.bottom - 80;

                    x.range([0, width]);
                    y.range([height, 0]);

                    svg.select('svg')
                        .attr('width', width + margin.left + margin.right)
                        .attr('height', height + margin.top + margin.bottom);

                    svg.select('#clip rect')
                        .attr('width', width)
                        .attr('height', height);

                    xAxis.call(d3.axisBottom(x)
                        .tickValues(initialTicks)
                        .tickFormat(d3.timeFormat("%Y-%m-%d")))
                        .attr('transform', `translate(0,${height})`);

                    yAxis.call(d3.axisLeft(y));

                    scatter.selectAll('path')
                        .attr('d', d => line(d.values));

                    scatter.selectAll('circle')
                        .attr('cx', d => x(new Date(d.date)))
                        .attr('cy', d => y(d.value));

                    // Remove and update legend
                    svg.selectAll(".legend").remove(); // Remove existing legends
                
                    // Update legend position
                    updateLegendPosition();

                });

                // Initialize legend position
                updateLegendPosition();
            
            // ALIOHJELMA PÄÄTTYY


        
        }

        function getSignByBoolean(isTrue) {
            if (isTrue) {
                return '<span style="color: green; font-size: 20px;">&#10003;</span>';
            }
            return '<span style="color: red; font-size: 20px;">&#10060;</span>';
        }
            
        function getSignByResult(result) {
            return getSignByBoolean(result === 'pass');
        }

        function addDailyResultInformation(timeValueQueryParam, serverQueryParam) {
            if (timeValueQueryParam) {
                const content = document.createElement('p');
                content.innerText = `Test execution time: ${timeValueQueryParam}`;
                document.getElementById('daily_result_information').appendChild(content);
            }
            if (serverQueryParam) {
                const content = document.createElement('p');
                content.innerText = `Test environment: ${serverQueryParam}`;
                document.getElementById('daily_result_information').appendChild(content);
            }
            // const horizontalLine = document.createElement('hr');
            // document.getElementById('daily_result_information').appendChild(horizontalLine);
        }

        function showDailySummary() {

            // const formatDate = d3.utcFormat("%Y-%m-%dT%H-%M-%S%Z");

            document.addEventListener('DOMContentLoaded', () => {

                document.getElementById('result_type').innerText = "Daily summary";

                addDailyResultInformation(timeValueQueryParam, serverQueryParam);

                // fetch(`http://localhost:3000/results-${serverQueryParam}.json`) // TOIMII
                // fetch(`http://localhost:3000/2024-07-14T00-00-00+00-00/results-qa.json`) // TOIMII
                // fetch(`http://localhost:3000/2024-07-14T00-00-00+00-00/results-${serverQueryParam}.json`) // TOIMII
                fetch(`./${timeValueQueryParam}/results-${serverQueryParam}.json`) // TOIMII
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Network response was not ok');
                        }
                        return response.json();
                    })
                    .then(data => {

                        let dataEntryIndex = 0;

                        for (let dataIndex = 0; dataIndex < data.length; dataIndex++) {
                            dataEntry = data[dataIndex];

                            const contentDiv = document.createElement('div');
                            contentDiv.innerHTML = `
                                <table>
                                    <tr>
                                        <td></td>
                                        <td>Passed</td>
                                        <td>Failed</td>
                                        <td>Total</td>
                                    </tr>
                                    <tr>
                                        <td>Requests</td>
                                        <td>${dataEntry.summary.passedRequests}</td>
                                        <td>${dataEntry.summary.failedRequests}</td>
                                        <td>${dataEntry.summary.totalRequests}</td>
                                    </tr>
                                    <tr>
                                        <td>Assertions</td>
                                        <td>${dataEntry.summary.passedAssertions}</td>
                                        <td>${dataEntry.summary.failedAssertions}</td>
                                        <td>${dataEntry.summary.totalAssertions}</td>
                                    </tr>
                                    <tr>
                                        <td>Tests</td>
                                        <td>${dataEntry.summary.passedTests}</td>
                                        <td>${dataEntry.summary.failedTests}</td>
                                        <td>${dataEntry.summary.totalTests}</td>
                                    </tr>
                                </table>
                            `;
                            document.getElementById('daily_summary').appendChild(contentDiv);

                            const content = document.createElement('h3');                             
                            content.innerText = `Requests`;
                            document.getElementById('daily_summary').appendChild(content);

                            for (let resultIndex = 0; resultIndex < dataEntry.results.length; resultIndex++) {
                                result = dataEntry.results[resultIndex]; 

                                let passedAssertionAmount = 0;
                                let totalAssertionAmount = result.assertionResults.length;

                                let passedTestAmount = 0;
                                let totalTestAmount = result.testResults.length;

                                const content = document.createElement('p');                             
                                content.innerHTML = `<span id="request_result_sign_${resultIndex}"></span> <span id="request_result_${resultIndex}"></span> <span id="request_result_numbers_${resultIndex}"></span> <a href="?server=${serverQueryParam}&time=${encodeURIComponent(timeValueQueryParam)}&dataEntryIndex=${dataEntryIndex}&resultIndex=${resultIndex}">${result.request.method} ${result.request.url}</a>`;
                                document.getElementById('daily_summary').appendChild(content);

                                /* Assertion results */

                                const assertionResultDiv = document.createElement('div');
                                const assertionResultTable = document.createElement('table');

                                const testResultDiv = document.createElement('div');
                                const testResultTable = document.createElement('table');

                                for (let assertionResultIndex = 0; assertionResultIndex < result.assertionResults.length; assertionResultIndex++) {
                                    const assertionResult = result.assertionResults[assertionResultIndex];
                                    console.log(assertionResult);
                                    if (assertionResult.status === 'pass') { 
                                        passedAssertionAmount++; 
                                    }
                                    if (resultIndexQueryParam && resultIndexQueryParam == resultIndex) {
                                        assertionResultTable.innerHTML += `
                                            <tr>
                                                <td>${getSignByResult(assertionResult.status)}</td>
                                                <td>${assertionResult.status.toUpperCase()}</td>
                                                <td>${assertionResult.lhsExpr} ${assertionResult.rhsExpr}</td>
                                            </tr>
                                        `;
                                    }
                                }

                                /* Test results */

                                for (let testResultIndex = 0; testResultIndex < totalTestAmount; testResultIndex++) {
                                    const testResult = result.testResults[testResultIndex];
                                    if (testResult.status === 'pass') { 
                                        passedTestAmount++; 
                                    }
                                    if (resultIndexQueryParam && resultIndexQueryParam == resultIndex) {
                                        testResultTable.innerHTML += `
                                            <tr>
                                                <td>${getSignByResult(testResult.status)}</td>
                                                <td>${testResult.status.toUpperCase()}</td>
                                                <td>${testResult.description}</td>
                                            </tr>
                                        `;
                                    }
                                }

                                assertionResultDiv.appendChild(assertionResultTable);
                                document.getElementById('daily_summary').appendChild(assertionResultDiv);     
                                testResultDiv.appendChild(testResultTable);
                                document.getElementById('daily_summary').appendChild(testResultDiv);

                                /* All assertions and tests passed */
                                console.log(passedAssertionAmount);
                                console.log(passedTestAmount);
                                console.log(totalAssertionAmount);
                                console.log(totalTestAmount);
                                const assertionsAndRequestsPassed = (passedAssertionAmount+passedTestAmount)/(totalAssertionAmount+totalTestAmount) === 1;
                                console.log(assertionsAndRequestsPassed);
                                document.getElementById(`request_result_sign_${resultIndex}`).innerHTML = getSignByBoolean(assertionsAndRequestsPassed);
                                document.getElementById(`request_result_${resultIndex}`).innerHTML = `${assertionsAndRequestsPassed ? "PASS" : "FAIL"}`;
                                document.getElementById(`request_result_numbers_${resultIndex}`).innerHTML = `(${passedAssertionAmount+passedTestAmount}/${totalAssertionAmount+totalTestAmount})`;
                            }

                        }
                    })
                    .catch(error => {
                        console.error('Error fetching JSON file:', error);
                    });
            });

        }

    </script>

</body>
</html>
