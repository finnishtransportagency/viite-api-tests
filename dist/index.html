<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Viite | API test results</title>
    <script src="./src/d3.v7.min.js"></script>
    <!-- <script src="https://d3js.org/d3.v7.min.js"></script> -->
    <link rel="stylesheet" href="./css/styles.css">
    <link rel="stylesheet" href="./css/vayla.css">
</head>
<body>
    <img src="./src/vayla_sivussa_fi_sv_rgb.png" width="494" height="200">
    <h1>Viite</h1>
    <h2>API test results</h2>
    <h3 id="result_type"></h3>
    <!-- <h4 id="environment"></h4> -->
    <!-- <h4 id="time"></h4> -->

    <div id="daily_result_information" class="content"></div>

    <div id="daily_results" class="content"></div>

    <div id="daily_summary" class="content"></div>
    
    <div id="graph" class="content">
        <div id="my_dataviz"></div>
        <div id="tooltip" class="tooltip"></div>
    </div>

    

    <script>

        // TS 29.7.2024: Checked
        // Should this be inside main-function?
        const urlParams = new URLSearchParams(window.location.search);
        const environmentQueryParam = urlParams.get('environment');
        const timeValueQueryParam = urlParams.get('time');
        const dataEntryIndexQueryParam = urlParams.get('dataEntryIndex');
        const resultIndexQueryParam = urlParams.get('resultIndex');

        // TS 29.7.2024: Checked
        document.addEventListener('DOMContentLoaded', () => {
            main();
        });

        /********
         ********
         * main *
         ********
         ********/

        async function main() {

            const baseURL = getBaseURL();

            // TS 29.7.2024: Checked
            // Remove commented code lines if app works
            document.getElementById('graph').classList.remove('active');
            document.getElementById('daily_result_information').classList.remove('active');
            document.getElementById('daily_summary').classList.remove('active');
            document.getElementById('daily_results').classList.remove('active');

            if (timeValueQueryParam && environmentQueryParam && dataEntryIndexQueryParam && resultIndexQueryParam) {
                setElementVisibleByElementId("daily_result_information");
                setElementVisibleByElementId("daily_summary");
                // document.getElementById('daily_result_information').classList.remove('content');
                // document.getElementById('daily_result_information').classList.add('active');
                // document.getElementById('daily_summary').classList.remove('content');
                // document.getElementById('daily_summary').classList.add('active');
                // fetchDataAndShowDailySummary();

                // const url = `${baseURL}${timeValueQueryParam}/results-${environmentQueryParam}.json`;
                const url = `${baseURL}${getDateTimeByEnvironment(timeValueQueryParam)}/results-${environmentQueryParam}.json`;
                fetchDataAndHandleErrors(url, showDailySummary);

                /*
                try {
                    const data = await fetchData(url);
                    showDailySummary(data);
                }
                catch (error) {
                    console.error('Error fetching data:', error);
                }
                */

            }
            else if (timeValueQueryParam && environmentQueryParam && resultIndexQueryParam) {
                setElementVisibleByElementId("daily_result_information");
                setElementVisibleByElementId("daily_summary");
                // document.getElementById('daily_result_information').classList.remove('content');
                // document.getElementById('daily_result_information').classList.add('active');
                // document.getElementById('daily_summary').classList.remove('content');
                // document.getElementById('daily_summary').classList.add('active');
                // fetchDataAndShowDailySummary();

                const url = `${baseURL}${getDateTimeByEnvironment(timeValueQueryParam)}/results-${environmentQueryParam}.json`;
                fetchDataAndHandleErrors(url, showDailySummary);

                /*
                try {
                    const data = await fetchData(url);
                    showDailySummary(data);
                }
                catch (error) {
                    console.error('Error fetching data:', error);
                }
                */

            }
            else if (timeValueQueryParam && environmentQueryParam) {
                setElementVisibleByElementId("daily_result_information");
                setElementVisibleByElementId("daily_summary");
                // document.getElementById('daily_result_information').classList.remove('content');
                // document.getElementById('daily_result_information').classList.add('active');
                // document.getElementById('daily_summary').classList.remove('content');
                // document.getElementById('daily_summary').classList.add('active');
                // fetchDataAndShowDailySummary();

                const url = `${baseURL}${getDateTimeByEnvironment(timeValueQueryParam)}/results-${environmentQueryParam}.json`;
                fetchDataAndHandleErrors(url, showDailySummary);

                /*
                try {
                    const data = await fetchData(url);
                    showDailySummary(data);
                }
                catch (error) {
                    console.error('Error fetching data:', error);
                }
                */

            }
            else {
                setElementVisibleByElementId("graph");
                // document.getElementById('graph').classList.remove('content');
                // document.getElementById('graph').classList.add('active');
                // fetchDataAndShowGraph();

                const url = `${baseURL}data/summary.json`;
                fetchDataAndHandleErrors(url, showGraph);

                /*
                try {
                    const data = await fetchData(url);
                    showGraph(data);
                }
                catch (error) {
                    console.error('Error fetching data:', error);
                }
                */

            }
        }

        // TS 29.7.2024: Checked
        function setElementVisibleByElementId(elementId) {
            const element = document.getElementById(elementId);
            if (element) {
                element.classList.remove("content");
                element.classList.add("active");
            }
        }

        // TS 29.7.2024: Checked
        function isLocal() {
            return window.location.protocol === 'file:';
        }

        // TS 29.7.2024: Checked
        // Determine base URL based on environment
        function getBaseURL() {
            if ( isLocal() ) {
                return 'http://localhost:3000/'; // Local development URL
            } else {
                return './'; // Production environment URL
            }
        }

        // TS 29.7.2024: Checked
        function gotoLoginPage() {
            if ( isLocal() ) {
                window.location.href = "https://viiteapitest.testivaylapilvi.fi/oauth2/";
                return;
            }
            window.location.href = "./oauth2/"; // USE THIS ON THE SERVER
            return; 
        }

        // TS 29.7.2024: Checked
        async function fetchDataAndHandleErrors(url, callback) {
            try {
                const data = await fetchData(url);
                if (data) {
                    callback(data);
                } else {
                    console.error('No data returned');
                }
            } catch (error) {
                console.error('Error fetching data:', error);
            }
        }

        // TS 29.7.2024: Checked
        function fetchData(url) {

            return fetch(url) // TOIMII
            .then(response => {
                if (!response.ok) {
                    // console.log(response);
                    console.log(response.status);
                    switch(response.status) {
                        case 403: 
                            gotoLoginPage();
                            return; 
                            /*
                            if ( isLocal() ) {
                                window.location.href = "https://viiteapitest.testivaylapilvi.fi/oauth2/";
                                return
                            }
                            window.location.href = "./oauth2/"; // USE THIS ON THE SERVER
                            return; 
                            */
                        case 404:
                            // gotoLoginPage();
                            // return;
                            // 
                            // window.location.href = "https://viiteapitest.testivaylapilvi.fi/oauth2/"; // DON*T USE THIS ON THE SERVER
                            // return; // DON*T USE THIS ON THE SERVER
                            throw new Error('404 Not Found: The requested resource could not be found.');    
                        case 500: 
                            throw new Error('500 Internal Environment Error: An error occurred on the environment.');
                        default: 
                            throw new Error(`HTTP error! status: ${response.status}`);
                    }
                }
                return response.json();
            })
            .catch(error => {
                if (error instanceof Error) {
                    console.error('Caught error: ', error.message);
                } 
                else {
                    console.error('Unknown error occurred: ', error);
                }
            });

        }

        function getDateTimeByEnvironment(date) {
            if ( isLocal() ) {
                const dateTimeInLocalFormat = convertDateTimeToLocalFormat(date); 
                return dateTimeInLocalFormat;
            }
            return date;
        }

        function convertDateTimeToLocalFormat(dateTime) {
            const dateTimeInLocalFormat = new Date(dateTime);
            if (isNaN(dateTimeInLocalFormat.getTime())) {
                throw new Error("Invalid date format");
            }

            const year = dateTimeInLocalFormat.getUTCFullYear();
            const month = String(dateTimeInLocalFormat.getUTCMonth() + 1).padStart(2, '0');
            const day = String(dateTimeInLocalFormat.getUTCDate()).padStart(2, '0');
            const hours = String(dateTimeInLocalFormat.getUTCHours()).padStart(2, '0');
            const minutes = String(dateTimeInLocalFormat.getUTCMinutes()).padStart(2, '0');
            const seconds = String(dateTimeInLocalFormat.getUTCSeconds()).padStart(2, '0');
            const offset_hours = dateTime.slice(-5, -3); 
            const offset_minutes = dateTime.slice(-2, -1) + dateTime.slice(-1);

            return `${year}-${month}-${day}T${hours}-${minutes}-${seconds}%2B${offset_hours}-${offset_minutes}`;
        }

        /*************
         *************
         * showGraph *
         *************
         *************/

        function showGraph(data) {

            document.getElementById('result_type').innerText = "Graph";

            // set the dimensions and margins of the graph
            const margin = {top: 50, right: 250, bottom: 50, left: 50};
            let width = window.innerWidth - margin.left - margin.right - 40;
            let height = window.innerHeight - margin.top - margin.bottom - 80; 

            let isMouseOverSvg = false;
            let isMouseOverCircle = false;

            // Define zoom behavior
            const zoom = d3.zoom()
                .scaleExtent([0.5, 500]) // min and max zoom
                .extent([[0, 0], [width, height]])
                .filter( event => {
                    return event.ctrlKey; // Zoom only when Ctrl key is pressed
                    // return event.ctrlKey && event.button === 0;
                    // return (event.ctrlKey || event.type === 'wheel') || (event.ctrlKey && event.button === 1);
                })
                .on("zoom", event => {
                    if (isMouseOverSvg && event.sourceEvent) {
                        updateChart(event);
                    }
                });
            
            // append the svg object to the body of the page
            const svg = d3.select("#my_dataviz")
                .append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                .append("g")
                    .attr("transform",`translate(${margin.left},${margin.top})`)
                .on("mouseenter", event => { 
                    isMouseOverSvg = true;
                    event.preventDefault();
                    printDebugMessages();
                })
                .on("mouseleave", () => { 
                    isMouseOverSvg = false;
                    printDebugMessages();
                })
                .call(zoom);

            const rect = svg.append("rect")
                .attr("width", width)
                .attr("height", height)
                .style("fill", "none")
                .style("pointer-events", "all")
                .attr('transform', `translate(0,0)`)
                // .call(zoom);





            // ALIOHJELMA ALKAA

            // Parse the date / time
            // const parseDate = d3.timeParse("%Y-%m-%d");
            // const parseDate = d3.timeParse("%Y-%m-%dT%H:%M:%S%Z");
            const parseDate = d3.utcParse("%Y-%m-%dT%H:%M:%S%Z");
            const formatDate = d3.utcFormat("%Y-%m-%dT%H:%M:%S%Z");

            /*
            data.forEach( (d) => {
                d.date = parseDate(d.date);
            });
            */

            /*
            const parsedData1 = [];
            for (let key in data) {
                // const parsedDate = parseDate(key.replace(/\//g, ""));
                const parsedDate = key.replace(/\//g, "");
                parsedData1.push({
                    date: parsedDate,
                    dev: data[key].dev,
                    qa: data[key].qa,
                    prod: data[key].prod
                });
            }
            */

            const parsedData = [];
            for (let key in data) {
                if (data.hasOwnProperty(key)) {
                    parsedData.push({
                        date: key.replace(/\//g, ""), // Säilytetään alkuperäinen päivämäärämerkkijono
                        dev: data[key].dev,
                        qa: data[key].qa,
                        prod: data[key].prod
                    });
                }
            }

            // console.log(parsedData);
            
            // sorts parsedData by date and time in ascending order
            parsedData.sort((a, b) => {
                const dateA = new Date(a.date);
                const dateB = new Date(b.date);
                return dateA - dateB;
            });
            
            // console.log(parsedData);

            // List of environments
            const allEnvironments = ["prod", "qa", "dev"];

            // environmentName is stored two times in the data. Can this be fixed?
            // Reformat the data
            const dataByEnvironments = allEnvironments.map(environmentName => {
                return {
                    name: environmentName,
                    values: parsedData.map(d => {
                        return {date: d.date, value: +d[environmentName], environment: environmentName};
                    })
                };
            });
            
            // Check that the data is ready
            console.log(dataByEnvironments)

            // A color scale: one color for each group
            const myColor = d3.scaleOrdinal()
                .domain(allEnvironments)
                // .range(d3.schemeSet2);
                // .range(["#0064AF", "#0099FF", "#49C2F1"]);
                .range(["#0064AF", "#0099FF", "#49C2F1", "#00B0CC", "#207A43", "#8DCB6D", "#FFC300", "#910AA3", "#C73F00", "#FF5100", "#E50083"]); // Customer's colors are being used

            // Generate unique tick values for the initial state
            const initialTicks = parsedData.map(d => new Date(d.date))
                .filter((d, i, self) => self.findIndex(t => t.getTime() === d.getTime()) === i);

            // Add X axis --> it is a date format
            const x = d3.scaleTime()
            // const x = d3.scaleUtc()
                .domain(d3.extent(parsedData, d => new Date(d.date)))
                .range([ 0, width ]);
            const xAxis = svg.append("g")
                .attr("transform", `translate(0, ${height})`)
                .call(d3.axisBottom(x)
                    .tickValues(initialTicks)
                    .tickFormat(d3.timeFormat("%Y-%m-%d"))
                    // .tickSize(0) // Ei viivoja
                    .tickPadding(10) // Puskuri akseleiden ja tekstien välillä
                );
                // .call(d3.axisBottom(x));
                // .call(d3.axisBottom(x).ticks(2));

            // Add Y axis
            const y = d3.scaleLinear()
                .domain([0, d3.max(parsedData, d => Math.max(d.prod, d.qa, d.dev) )])
                .nice()
                .range([ height, 0 ]);
            const yAxis = svg.append("g")
                .call(d3.axisLeft(y)
                    .tickFormat(d3.format("d"))
                );
                // .call(d3.axisLeft(y).ticks(20));

            // Add the lines
            const line = d3.line()
                .x(d => x(+(new Date(d.date))))
                .y(d => y(+d.value));

            /*
            svg.selectAll("myLines")
                .data(dataByEnvironments)
                .join("path")
                    .attr("d", d => line(d.values))
                    .attr("stroke", d => myColor(d.name))
                    .style("stroke-width", 4)
                    .style("fill", "none")
            */

            // Moved elsewhere
            /*
            // Define zoom behavior
            const zoom = d3.zoom()
                .scaleExtent([0.5, 1000]) // min and max zoom
                .extent([[0, 0], [width, height]])
                .filter( event => {
                    return event.ctrlKey; // Zoom only when Ctrl key is pressed
                    // return event.ctrlKey && event.button === 0;
                    // return (event.ctrlKey || event.type === 'wheel') || (event.ctrlKey && event.button === 1);
                })
                .on("zoom", event => {
                    if (isMouseOverSvg && event.sourceEvent) {
                        updateChart(event);
                    }
                });
            */

            // Moved elsewhere
            /*
            svg.on("mouseenter", event => { 
                isMouseOverSvg = true;
                event.preventDefault();
                printDebugMessages();
            });
            */

            // Moved elsewhere
            /*
            svg.on("mouseleave", () => { 
                isMouseOverSvg = false;
                printDebugMessages();
            });
            */

            // svg.call(zoom);

            // Add a clipPath: everything out of this area won't be drawn.
            const clip = svg.append("defs")
                .append("svg:clipPath")
                .attr("id", "clip")
                .append("svg:rect")
                .attr("width", width )
                .attr("height", height )
                .attr("x", 0)
                .attr("y", 0);

            /******************
            * Mouse functions *
            *******************/

            function mouseover(event, d) {
                if (!event.ctrlKey) {
                    isMouseOverCircle = true;
                    showTooltip(event, d);
                } 
            }

            function mouseout() {
                isMouseOverCircle = false;
                hideTooltip();
            }

            function mouseclick(event, d) {
                // formattedDate = formatDate(d.date);
                // const timezone = formattedDate.slice(-6); // +00:00
                // const isoString = `${formattedDate.slice(0,19)}%2B${timezone.slice(2, 4)}:${timezone.slice(4)}`;
                // window.location.href = `?environment=${d.environment}&time=${encodeURIComponent(d.date)}`;
                window.location.href = `?environment=${d.environment}&time=${encodeURIComponent(d.date)}`;
            }

            // Create the scatter variable: where both the circles and the brush take place
            const scatter = svg.append('g')
                .attr("clip-path", "url(#clip)")



            // Add lines
            scatter
                .selectAll("myLines")
                .data(dataByEnvironments)
                .join("path")
                    .attr("data-env", d => d.name)
                    .attr("class", "path")
                    .attr("stroke", d => myColor(d.name))
                    .attr("d", d => line(d.values))
                    .style("stroke-width", 4)
                    .style("fill", "none");

            // Add circles
            scatter
                // First we need to enter in a group
                .selectAll("myDots")
                .data(dataByEnvironments)
                .join('g')
                    .style("fill", d => myColor(d.name))
                // Second we need to enter in the 'values' part of this group
                .selectAll("myPoints")
                .data(d => d.values)
                .join("circle")
                    .attr("data-env", d => d.environment)
                    .attr("cx", d => x(new Date(d.date)))
                    .attr("cy", d => y(d.value))
                    .attr("r", 5)
                    .attr("stroke", "white")
                    .on("mouseover", mouseover)
                    .on("mouseout", mouseout)
                    .on("click", mouseclick);

            /*************
             * Functions *
             *************/
            
            /*********************
             * Tooltip functions *
             *********************/

            function showTooltip(event, d) {
                const tooltip = document.getElementById("tooltip");
                tooltip.style.display = "block";
                tooltip.style.left = event.pageX + 15 + "px";
                tooltip.style.top = event.pageY + 15 +"px";
                // tooltip.textContent = "Tooltip: You are over the circle.";
                // tooltip.textContent = `environment: ${d.environment} passed tests: ${d.value} date: ${d.date}`;
                tooltip.innerHTML = `
                    environment: ${d.environment}<br>
                    passed tests: ${d.value}<br>
                    date: ${d.date}
                `;
            }

            function showTooltip2(event, d) {
                const tooltip = d3.select("#tooltip");

                tooltip.transition()
                    .duration(200)
                    .style("opacity", .9);

                tooltip
                    .style("display", "block")
                    .style("left", (event.pageX + 15) + "px")
                    .style("top", (event.pageY + 15) + "px")
                    .html(`
                        environment: ${d.environment}<br>
                        passed tests: ${d.value}<br>
                        date: ${d.date}
                    `);

                tooltip.transition()
                    .duration(200)
                    .style("opacity", .9);
            }

            function hideTooltip() {
                const tooltip = document.getElementById("tooltip");
                tooltip.style.display = "none";
            }



            /*******************
             * Other functions *
             *******************/

            // Debug messages
            function printDebugMessages() {
                console.log(`isMouseOverSvg: ${isMouseOverSvg}`);
                console.log("*****")
            }

            function isPathHiddenByDataEnv(dataEnv) {
                const paths = svg.selectAll(`path[data-env="${dataEnv}"]`);
                let isHidden = paths.classed("hidden");
                return isHidden;
            }
            
            function toggleLegendDimming(event, d, self) {
                const isActive = d3.select(self).classed("dimmed");
                d3.select(self).classed("dimmed", !isActive);
                svg.selectAll(`.line`).filter(lineD => lineD.name === d.name).style("display", isActive ? null : "none");
            }

            function setLegendVisibilityByDataEnv(dataEnv, visibility) {
                // const legend = d3.select(`#${id}`);
                const legends = svg.selectAll(`legend[data-env="${dataEnv}"]`);
                legends.classed("dimmed", visibility);
            }

            function setLegendVisibilityByD(d, visibility) {
                return setLegendVisibilityByDataEnv(d.name, visibility);
            }

            function setCircleVisibilityByDataEnv(dataEnv, visibility) {
                // const circle = d3.select(`#${id}`);
                const circles = svg.selectAll(`circle[data-env="${dataEnv}"]`);
                circles.classed("hidden", visibility);
            }

            function setCircleVisibilityByD(d, visibility) {
                return setCircleVisibilityByDataEnv(d.name, visibility);
            }

            function togglePathVisibilityByDataEnv(dataEnv) {
                // const path = d3.select(`#${id}`);
                const paths = svg.selectAll(`path[data-env="${dataEnv}"]`);
                // console.log(path);
                let isHidden = paths.classed("hidden");
                paths.classed("hidden", !isHidden)
                isHidden = paths.classed("hidden");
                return isHidden;
            }

            function togglePathVisibilityByD(d) {
                // console.log(d);
                // console.log(`path_${d.name}`);
                return togglePathVisibilityByDataEnv(d.name);
            }

            function toggleLegendAndPathAndCircleVisibilityByD(d, self) {
                const visibility = togglePathVisibilityByD(d); 
                setCircleVisibilityByD(d, visibility);
                d3.select(self).classed("dimmed", visibility)
                // setLegendVisibilityByD(d, visibility);
            }

            // Toggle visibility function
            function togglePathAndCircleVisibility(name) {
                // Select paths and circles by name
                const path = scatter.selectAll("path")
                    .filter(d => d.name === name);
                
                const circles = scatter.selectAll("circle")
                    .filter(function(d) {
                        return d3.select(this.parentNode).datum().name === name;
                    });

                // Toggle hidden class based on current state
                const isHidden = path.classed("hidden");
                path.classed("hidden", !isHidden);
                circles.classed("hidden", !isHidden);
            }

            // Add a legends
            const legend = svg.selectAll("myLegends")
                .data(dataByEnvironments)
                .enter()
                .append("g")
                    .attr("data-env", d => d.name)
                    .attr("class", "legend")
                    .attr("transform", (d, i) => `translate(${width + 20},${i * 20})`)
                    .on("click", function(event, d) {
                        toggleLegendAndPathAndCircleVisibilityByD(d, this); // OPTION 2
                        // toggleLegendDimming(event, d, this); // OPTION 1
                        // togglePathAndCircleVisibility(d.name); // OPTION 1
                    });


            legend.append("rect")
                .attr("x", 0)
                .attr("width", 18)
                .attr("height", 18)
                .style("fill", d => myColor(d.name))
                // .on("click", (event, d) => {
                    // togglePathAndCircleVisibility(d.name);
                // });

            legend.append("text")
                .attr("x", 24)
                .attr("y", 9)
                .attr("dy", ".35em")
                .style("text-anchor", "start")
                .text(d => d.name)
                // .on("click", (event, d) => {
                    // togglePathAndCircleVisibility(d.name);
                // });





            /**************
            ***************
            * updateChart *
            ***************
            ***************/

            // A function that updates the chart when the user zoom and thus new boundaries are available
            function updateChart(event) {

                // recover the new scale
                let newX = event.transform.rescaleX(x);
                let newY = event.transform.rescaleY(y);

                // Generate unique tick values based on the new scale's domain
                const newDomain = newX.domain();
                const uniqueTicks = parsedData.map(d => new Date(d.date))
                    .filter(d => d >= newDomain[0] && d <= newDomain[1])
                    .filter((d, i, self) => self.findIndex(t => t.getTime() === d.getTime()) === i)

                // update axes with these new boundaries
                xAxis.call(d3.axisBottom(newX)
                    .tickValues(uniqueTicks)
                    .tickFormat(d3.timeFormat("%Y-%m-%d")));
                yAxis.call(d3.axisLeft(newY));

                scatter
                    .selectAll("path")
                    .attr("d", d => d3.line()
                        .x(d => newX(+(new Date(d.date))))
                        .y(d => newY(+d.value))(d.values)
                    );

                // update circles
                scatter
                    .selectAll("circle")
                    .attr("cx", d => newX(new Date(d.date)))
                    .attr("cy", d => newY(d.value));
            }

            /***********************
            ************************
            * updateLegendPosition *
            ************************
            ************************/

            // Function to update legend position
            function updateLegendPosition() {
                const legendSpacing = 20;
                const legendWidth = 100;
                const totalGroups = dataByEnvironments.length;
                const svgWidth = width + margin.left + margin.right;
                const legendX = svgWidth - legendWidth - 10; // Position legend on the right

                const legend = svg.selectAll(".legend")
                    .data(dataByEnvironments)
                    .enter()
                    .append("g")
                    .attr("class", "legend")
                    .classed("dimmed", d => isPathHiddenByDataEnv(d.name))
                    .attr("transform", (d, i) => `translate(${width + 20},${i * 20})`)
                    .on("click", function(event, d) {
                        toggleLegendAndPathAndCircleVisibilityByD(d, this); // OPTION 2
                        // toggleLegendDimming(event, d, this); // OPTION 1
                        // togglePathAndCircleVisibility(d.name); // OPTION 1
                    });
                    // .attr("transform", (d, i) => `translate(${legendX},${i * legendSpacing})`);

                legend.append("rect")
                    .attr("x", 0)
                    .attr("width", 18)
                    .attr("height", 18)
                    .style("fill", d => myColor(d.name))
                    // .on("click", (event, d) => {
                        // togglePathAndCircleVisibility(d.name);
                    // });

                legend.append("text")
                    .attr("x", 24)
                    .attr("y", 9)
                    .attr("dy", ".35em")
                    .style("text-anchor", "start")
                    .text(d => d.name)
                    // .on("click", (event, d) => {
                        // togglePathAndCircleVisibility(d.name);
                    // });
            }

            /**************************
            ***************************
            * window.addEventListener *
            ***************************
            ***************************/

            // Event listener to handle Ctrl key state and tooltip display
            window.addEventListener('keydown', event => {
                if (event.key === 'Control' && isMouseOverCircle) {
                    hideTooltip();
                }
            });

            // DOES NOT WORK, showTooltip CAUSES EXECPTION
            window.addEventListener('keyup', (event, d) => {
                if (event.key === 'Control' && isMouseOverCircle) {
                    // Causes exception
                    showTooltip(event, d);
                }
            });

            // DOES NOT WORK, IF CTRL IS BEING PRESSED
            // WORKS ONLY WHEN WHEEL IS BEING USED
            // Prevent default scroll behavior when Ctrl key is pressed
            window.addEventListener('wheel', event => {
                // if (event.ctrlKey && isMouseOverSvg && (isMouseOverCircle || svg.node().contains(event.target))) {
                if (event.ctrlKey && isMouseOverSvg) {
                    event.preventDefault();
                }
            }, { passive: false });

            window.addEventListener("resize", () => {
                width = window.innerWidth - margin.left - margin.right - 40;
                height = window.innerHeight - margin.top - margin.bottom - 80;

                x.range([0, width]);
                y.range([height, 0]);

                svg.select('svg')
                    .attr('width', width + margin.left + margin.right)
                    .attr('height', height + margin.top + margin.bottom);

                svg.select('#clip rect')
                    .attr('width', width)
                    .attr('height', height);

                xAxis.call(d3.axisBottom(x)
                    .tickValues(initialTicks)
                    .tickFormat(d3.timeFormat("%Y-%m-%d")))
                    .attr('transform', `translate(0,${height})`);

                yAxis.call(d3.axisLeft(y));

                scatter.selectAll('path')
                    .attr('d', d => line(d.values));

                scatter.selectAll('circle')
                    .attr('cx', d => x(new Date(d.date)))
                    .attr('cy', d => y(d.value));

                // Remove and update legend
                svg.selectAll(".legend").remove(); // Remove existing legends
            
                // Update legend position
                updateLegendPosition();

            });

            // Initialize legend position
            updateLegendPosition();
            
            // ALIOHJELMA PÄÄTTYY
        }

        /********************
         ********************
         * showDailySummary *
         ********************
         * FUNCTIONS        *
         ********************
         ********************/


        function getSignByBoolean(isTrue) {
            if (isTrue) {
                return '<span style="color: green; font-size: 20px;">&#10003;</span>';
            }
            return '<span style="color: red; font-size: 20px;">&#10060;</span>';
        }
            
        function getSignByResult(result) {
            return getSignByBoolean(result === 'pass');
        }

        function addDailyResultInformation(timeValueQueryParam, environmentQueryParam) {
            if (timeValueQueryParam) {
                const content = document.createElement('p');
                content.innerText = `Test execution time: ${timeValueQueryParam}`;
                document.getElementById('daily_result_information').appendChild(content);
            }
            if (environmentQueryParam) {
                const content = document.createElement('p');
                content.innerText = `Test environment: ${environmentQueryParam}`;
                document.getElementById('daily_result_information').appendChild(content);
            }
            // const horizontalLine = document.createElement('hr');
            // document.getElementById('daily_result_information').appendChild(horizontalLine);
        }

        /********************
         ********************
         * showDailySummary *
         ********************
         ********************/

        function showDailySummary(data) {

            // const formatDate = d3.utcFormat("%Y-%m-%dT%H-%M-%S%Z");

            document.getElementById('result_type').innerText = "Daily summary";

            addDailyResultInformation(timeValueQueryParam, environmentQueryParam);

            let dataEntryIndex = 0;

            console.log(data)

            for (let dataIndex = 0; dataIndex < data.length; dataIndex++) {
                dataEntry = data[dataIndex];

                const contentDiv = document.createElement('div');
                contentDiv.innerHTML = `
                    <table>
                        <tr>
                            <td></td>
                            <td>Passed</td>
                            <td>Failed</td>
                            <td>Total</td>
                        </tr>
                        <tr>
                            <td>Requests</td>
                            <td>${dataEntry.summary.passedRequests}</td>
                            <td>${dataEntry.summary.failedRequests}</td>
                            <td>${dataEntry.summary.totalRequests}</td>
                        </tr>
                        <tr>
                            <td>Assertions</td>
                            <td>${dataEntry.summary.passedAssertions}</td>
                            <td>${dataEntry.summary.failedAssertions}</td>
                            <td>${dataEntry.summary.totalAssertions}</td>
                        </tr>
                        <tr>
                            <td>Tests</td>
                            <td>${dataEntry.summary.passedTests}</td>
                            <td>${dataEntry.summary.failedTests}</td>
                            <td>${dataEntry.summary.totalTests}</td>
                        </tr>
                    </table>
                `;
                document.getElementById('daily_summary').appendChild(contentDiv);

                const content = document.createElement('h3');                             
                content.innerText = `Requests`;
                document.getElementById('daily_summary').appendChild(content);

                for (let resultIndex = 0; resultIndex < dataEntry.results.length; resultIndex++) {
                    result = dataEntry.results[resultIndex]; 

                    let passedAssertionAmount = 0;
                    let totalAssertionAmount = result.assertionResults.length;

                    let passedTestAmount = 0;
                    let totalTestAmount = result.testResults.length;

                    const content = document.createElement('p');                             
                    content.innerHTML = `<span id="request_result_sign_${resultIndex}"></span> <span id="request_result_${resultIndex}"></span> <span id="request_result_numbers_${resultIndex}"></span> <a href="?environment=${environmentQueryParam}&time=${encodeURIComponent(timeValueQueryParam)}&dataEntryIndex=${dataEntryIndex}&resultIndex=${resultIndex}">${result.request.method} ${result.request.url}</a>`;
                    // content.innerHTML = `<span id="request_result_sign_${resultIndex}"></span> <span id="request_result_${resultIndex}"></span> <span id="request_result_numbers_${resultIndex}"></span> <a href="?environment=${environmentQueryParam}&time=${getDateTimeByEnvironment(timeValueQueryParam)}&dataEntryIndex=${dataEntryIndex}&resultIndex=${resultIndex}">${result.request.method} ${result.request.url}</a>`;
                    document.getElementById('daily_summary').appendChild(content);

                    /* Assertion results */

                    const assertionResultDiv = document.createElement('div');
                    const assertionResultTable = document.createElement('table');

                    const testResultDiv = document.createElement('div');
                    const testResultTable = document.createElement('table');

                    for (let assertionResultIndex = 0; assertionResultIndex < result.assertionResults.length; assertionResultIndex++) {
                        const assertionResult = result.assertionResults[assertionResultIndex];
                        console.log(assertionResult);
                        if (assertionResult.status === 'pass') { 
                            passedAssertionAmount++; 
                        }
                        if (resultIndexQueryParam && resultIndexQueryParam == resultIndex) {
                            assertionResultTable.innerHTML += `
                                <tr>
                                    <td>${getSignByResult(assertionResult.status)}</td>
                                    <td>${assertionResult.status.toUpperCase()}</td>
                                    <td>${assertionResult.lhsExpr} ${assertionResult.rhsExpr}</td>
                                </tr>
                            `;
                        }
                    }

                    /* Test results */

                    for (let testResultIndex = 0; testResultIndex < totalTestAmount; testResultIndex++) {
                        const testResult = result.testResults[testResultIndex];
                        if (testResult.status === 'pass') { 
                            passedTestAmount++; 
                        }
                        if (resultIndexQueryParam && resultIndexQueryParam == resultIndex) {
                            testResultTable.innerHTML += `
                                <tr>
                                    <td>${getSignByResult(testResult.status)}</td>
                                    <td>${testResult.status.toUpperCase()}</td>
                                    <td>${testResult.description}</td>
                                </tr>
                            `;
                        }
                    }

                    assertionResultDiv.appendChild(assertionResultTable);
                    document.getElementById('daily_summary').appendChild(assertionResultDiv);     
                    testResultDiv.appendChild(testResultTable);
                    document.getElementById('daily_summary').appendChild(testResultDiv);

                    /* All assertions and tests passed */
                    console.log(passedAssertionAmount);
                    console.log(passedTestAmount);
                    console.log(totalAssertionAmount);
                    console.log(totalTestAmount);
                    const assertionsAndRequestsPassed = (passedAssertionAmount+passedTestAmount)/(totalAssertionAmount+totalTestAmount) === 1;
                    console.log(assertionsAndRequestsPassed);
                    document.getElementById(`request_result_sign_${resultIndex}`).innerHTML = getSignByBoolean(assertionsAndRequestsPassed);
                    document.getElementById(`request_result_${resultIndex}`).innerHTML = `${assertionsAndRequestsPassed ? "PASS" : "FAIL"}`;
                    document.getElementById(`request_result_numbers_${resultIndex}`).innerHTML = `(${passedAssertionAmount+passedTestAmount}/${totalAssertionAmount+totalTestAmount})`;
                }

            }

        }

    </script>

</body>
</html>
